# Release 9: If/Else Conditionals + Code Highlighting

> Follow CLAUDE.md - do not implement until user approves complete release plan.

## Code Quality Analysis

**Current codebase:** 5,254 lines across 21 files (13 src, 8 tests, 3 css, 1 html)
**Tests:** 139 passing

### Issues to Address

| Priority | Issue | Action |
|----------|-------|--------|
| **MONITOR** | interpreter.css at 512 lines | Consider splitting if grows past 600 |
| **MONITOR** | scanner.js at 384 lines | OK - state machine is inherently complex |

No critical issues. Codebase is healthy.

---

## Goals

### 1. If/Else Conditionals (from original roadmap)

Implement if/else execution in the interpreter. The parser already handles if/else - we just need to interpret it.

### 2. Code Highlighting During Execution

**Highlight the currently executing code** in the Code pane, synchronized with AST node highlighting.

When the interpreter enters an AST node during animated execution, the corresponding source code should pulse/highlight - showing Connor exactly which code is running.

## Current State

- Parser handles if/else syntax (creates IfStatement AST nodes)
- Interpreter throws "If statements not yet supported" error
- AST nodes highlight during execution (Release 7)
- But the Code pane shows static source code
- No visual connection between code and what's executing

---

## Feature 1: If/Else Conditionals

### Language Syntax

```
if (condition) {
  // then branch
}

if (condition) {
  // then branch
} else {
  // else branch
}
```

### Interpreter Implementation

Add case for IfStatement in interpreter's execute method:

```javascript
case 'IfStatement': {
  const condition = await this.evaluate(node.condition);
  if (this.isTruthy(condition)) {
    result = await this.execute(node.thenBranch);
  } else if (node.elseBranch) {
    result = await this.execute(node.elseBranch);
  }
  break;
}
```

Add truthiness helper:
```javascript
isTruthy(value) {
  if (value === null || value === undefined) return false;
  if (typeof value === 'boolean') return value;
  return true;  // numbers and strings are truthy
}
```

### Tests for If/Else

1. **"if true executes then branch"**
   - Run: `if (true) { print "yes" }`
   - Output: `yes`

2. **"if false skips then branch"**
   - Run: `if (false) { print "no" }`
   - Output: (empty)

3. **"if-else executes else when false"**
   - Run: `if (false) { print "then" } else { print "else" }`
   - Output: `else`

4. **"if with comparison"**
   - Run: `let x = 10\nif (x > 5) { print "big" }`
   - Output: `big`

5. **"if-else with variable condition"**
   - Run: `let flag = true\nif (flag) { print "yes" } else { print "no" }`
   - Output: `yes`

6. **"nested if statements"**
   - Run: `if (true) { if (true) { print "nested" } }`
   - Output: `nested`

7. **"if modifies variables"**
   - Run: `let x = 1\nif (true) { x = 2 }\nprint x`
   - Output: `2`

---

## Feature 2: Code Highlighting

### Visual Design

```
┌─────────────────┐  ┌─────────────────────────┐  ┌─────────────────┐
│      Code       │  │       Interpreter       │  │     Output      │
├─────────────────┤  ├─────────────────────────┤  ├─────────────────┤
│ let x = 42      │  │         [AST]           │  │                 │
│ ████████████    │  │    ┌─────────────┐      │  │                 │
│ print x + 1     │  │    │ PrintStmt ● │      │  │                 │
│                 │  │    └─────────────┘      │  │                 │
└─────────────────┘  └─────────────────────────┘  └─────────────────┘
     ▲                        ▲
     │                        │
     └────── synchronized ────┘
```

When `PrintStatement` node is executing:
- AST node pulses (existing behavior)
- Code line `print x + 1` also pulses with matching animation

### Implementation Approach

**Key insight:** Tokens already have all position info. AST nodes should reference tokens, not duplicate data.

#### Design: Token References in AST

Tokens already have location info:
```javascript
// Token structure (from lexer)
{
  type: 'KEYWORD',
  value: 'let',
  line: 1,
  column: 1,
  raw: 'let',
  start: 0,   // Already tracked by lexer
  end: 3      // Already tracked by lexer
}
```

AST nodes reference their tokens:
```javascript
// AST node with token references
{
  type: 'LetStatement',
  name: nameToken.value,
  value: value,
  token: letKeywordToken,      // First token of this node
  endToken: lastValueToken     // Last token (for multi-token spans)
}
```

To get the span for highlighting:
```javascript
function getSpan(node) {
  const start = node.token.start;
  const end = node.endToken ? node.endToken.end : node.token.end;
  return { start, end };
}
```

#### Step 1: Add start/end to All Tokens

Update lexer to include `start` and `end` on every token:
```javascript
makeToken(type, value, raw) {
  return {
    type,
    value,
    line: this.tokenLine,
    column: this.tokenColumn,
    raw,
    start: this.tokenStart,
    end: this.pos
  };
}
```

#### Step 2: Store Token References in Parser

```javascript
parseLetStatement() {
  const letToken = this.previous();  // 'let' keyword we just matched
  const nameToken = this.consume('IDENTIFIER', null, "...");
  this.consume('OPERATOR', '=', "...");
  const value = this.parseExpression();
  const endToken = this.previous();  // Last token of expression

  return {
    type: 'LetStatement',
    name: nameToken.value,
    value: value,
    token: letToken,
    endToken: endToken
  };
}
```

#### Step 3: Highlight Code on Node Enter

```javascript
const interpreter = new Interpreter({
  stepDelay: 5000,
  onNodeEnter: (node) => {
    astRenderer.highlightNode(node);
    if (node.token) {
      const span = getSpan(node);
      visualizer.highlightExecuting(span);
    }
  }
});
```

The `visualizer.highlight(span)` method already exists from Release 6!

### Visual Styling

Reuse the pulse animation from AST highlighting:
```css
.code-display .code-executing {
  animation: code-pulse 0.8s ease-in-out infinite;
  background: rgba(74, 122, 255, 0.3);
  border-radius: 2px;
}

@keyframes code-pulse {
  0%, 100% { background: rgba(74, 122, 255, 0.3); }
  50% { background: rgba(74, 122, 255, 0.5); }
}
```

## File Changes

```
src/
  interpreter.js     # Add IfStatement, Block cases + isTruthy()
  lexer.js           # Add start/end to all tokens
  parser.js          # Add token references to all AST nodes
  visualizer.js      # Add highlightExecuting() method
  main.js            # Connect onNodeEnter to visualizer
styles/
  interpreter.css    # Add .code-executing styles
tests/
  conditionals.spec.js    # NEW - if/else tests
  code-highlight.spec.js  # NEW - code highlighting tests
```

## Implementation Details

### Lexer Changes

Add `start` and `end` to all token creation methods. The lexer already tracks `tokenStart` - just include it in the returned token:

```javascript
// Update all places tokens are created to include start/end
return {
  type,
  value,
  line: this.tokenLine,
  column: this.tokenColumn,
  raw,
  start: this.tokenStart,
  end: this.pos
};
```

### Parser Changes

Add `previous()` helper (may already exist):
```javascript
previous() {
  return this.tokens[this.pos - 1];
}
```

Add token references to each node type:

| Node Type | token | endToken |
|-----------|-------|----------|
| LetStatement | 'let' keyword | last token of value expr |
| AssignStatement | identifier | last token of value expr |
| PrintStatement | 'print' keyword | last token of expr |
| IfStatement | 'if' keyword | closing '}' |
| WhileStatement | 'while' keyword | closing '}' |
| Block | opening '{' | closing '}' |
| ExpressionStatement | first token of expr | last token of expr |
| BinaryExpression | left.token | right.endToken or right.token |
| NumberLiteral | the number token | (same) |
| StringLiteral | the string token | (same) |
| BooleanLiteral | true/false token | (same) |
| Identifier | the identifier token | (same) |

### Visualizer Changes

Add a new highlight mode for execution:
```javascript
// Highlight code span during execution (with pulse animation)
highlightExecuting(span) {
  if (!this.source || !span) return;

  const before = this.escapeHtml(this.source.substring(0, span.start));
  const current = this.escapeHtml(this.source.substring(span.start, span.end));
  const after = this.escapeHtml(this.source.substring(span.end));

  this.container.innerHTML =
    `<span class="code-done">${before}</span>` +
    `<span class="code-executing">${current}</span>` +
    `<span class="code-pending">${after}</span>`;
}

clearExecutingHighlight() {
  // Show source without highlighting
  this.showInitial();
}
```

## Playwright Tests

### Code Highlight Tests (new file: code-highlight.spec.js)

1. **"code highlights during animated run"**
   - Run animated: `let x = 42`
   - Verify `.code-executing` class appears on code

2. **"code highlight matches AST highlight"**
   - Run animated: `let x = 42\nprint x`
   - When AST shows LetStatement highlighted, code shows `let x = 42` highlighted
   - When AST shows PrintStatement highlighted, code shows `print x` highlighted

3. **"code highlight moves through statements"**
   - Run animated with multiple statements
   - Verify highlight moves from first to last statement

4. **"code highlight cleared after execution"**
   - Run animated to completion
   - Verify no `.code-executing` class remains

5. **"code highlight works with if statement"**
   - Run animated: `if (true) { print 1 }`
   - Verify if statement and inner print both highlight at appropriate times

6. **"code highlight works with while loop"**
   - Run animated: `let i = 0\nwhile (i < 2) { i = i + 1 }`
   - Verify while condition highlights each iteration

7. **"code highlight spans correct characters"**
   - Run animated: `let longVariableName = 12345`
   - Verify the entire statement is highlighted, not just a portion

8. **"no code highlight during Run Fast"**
   - Click Run Fast
   - Verify no `.code-executing` class (too fast to see)

### Existing Test Updates

Update any tests that check code display content to account for new span-based rendering.

## Deliverables

### If/Else Implementation
- [ ] Add IfStatement case to interpreter execute()
- [ ] Add Block case to interpreter execute()
- [ ] Add isTruthy() helper method
- [ ] Create tests/conditionals.spec.js with 7 tests

### Lexer Enhancement (for code highlighting)
- [ ] Add `start`, `end` to all tokens

### Parser Enhancement (for code highlighting)
- [ ] Add `previous()` helper if not present
- [ ] Add `token` and `endToken` references to all AST node types

### Visualizer Enhancement
- [ ] Add `highlightExecuting(span)` method
- [ ] Add `clearExecutingHighlight()` method

### Integration
- [ ] Add `getSpan(node)` helper function
- [ ] Update main.js `onNodeEnter` to call visualizer
- [ ] Add CSS for `.code-executing` animation

### Tests
- [ ] tests/conditionals.spec.js - 7 tests for if/else
- [ ] tests/code-highlight.spec.js - 8 tests for highlighting
- [ ] All tests passing (154+ total)

## Notes

**Why token references instead of duplicating span data:**
- Tokens already have all position info (start, end, line, column)
- No data duplication - AST nodes stay lightweight
- Single source of truth for source positions
- Easy to derive any span info when needed

**Why this matters for learning:**
- Shows the direct connection between source code and execution
- Connor can see exactly which code is running
- Reinforces that the interpreter walks the AST, which maps back to code

**Future enhancement:**
- Could show expression evaluation within a line (e.g., highlight `x + 1` then `43`)
- Could show variable values inline during execution

## Status

**COMPLETE** - 154 tests passing

### Completed Deliverables

- [x] Add IfStatement case to interpreter execute()
- [x] Add Block case to interpreter execute()
- [x] Add isTruthy() helper method
- [x] Create tests/conditionals.spec.js with 7 tests
- [x] Add `start`, `end` to all tokens in lexer
- [x] Add `previous()` helper to parser
- [x] Add `token` and `endToken` references to all AST node types
- [x] Add `highlightExecuting(span)` method to visualizer
- [x] Add `clearExecutingHighlight()` method to visualizer
- [x] Add `getNodeSpan(node)` helper function in main.js
- [x] Update main.js `onNodeEnter` to call visualizer
- [x] Add CSS for `.code-executing` animation
- [x] tests/conditionals.spec.js - 7 tests for if/else
- [x] tests/code-highlight.spec.js - 8 tests for highlighting
- [x] All tests passing (154 total)
