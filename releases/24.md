# Release 24: Code Quality Improvements

## Goal
Address code quality issues identified in the codebase analysis to improve maintainability, reduce duplication, and clarify architecture.

## Current State (Score: 8/10)

| Dimension | Score | Status |
|-----------|-------|--------|
| File Sizes | 8/10 | GOOD |
| Duplication | 7/10 | FAIR |
| Test Coverage | 10/10 | EXCELLENT |
| Documentation | 7/10 | GOOD |
| Error Handling | 8/10 | GOOD |
| Naming | 9/10 | GOOD |
| Dead Code | 9/10 | GOOD |
| Security | 8/10 | GOOD |
| Performance | 8/10 | GOOD |
| Architecture | 7/10 | GOOD |

---

## Issue 1: Argument Validation Duplication

### Problem
25 repeated argument validation patterns in `interpreter.js` `tryBuiltinCall()`:

```javascript
// Repeated 25 times with slight variations
if (args.length !== 1) {
  throw new RuntimeError('print() requires 1 argument');
}
```

### Solution
Extract validation helper to `runtime.js`:

```javascript
// runtime.js
export function validateArgs(args, expected, funcName) {
  if (args.length !== expected) {
    throw new RuntimeError(
      `${funcName}() requires ${expected} argument${expected !== 1 ? 's' : ''}, got ${args.length}`
    );
  }
}

export function validateArgTypes(args, types, funcName) {
  for (let i = 0; i < types.length; i++) {
    if (typeof args[i] !== types[i]) {
      throw new RuntimeError(
        `${funcName}() argument ${i + 1} must be ${types[i]}, got ${typeof args[i]}`
      );
    }
  }
}
```

### Files Changed
- `src/runtime.js` - Add helper functions
- `src/interpreter.js` - Use helpers in tryBuiltinCall()

### Tests
- Existing tests should pass (behavior unchanged)
- Error messages will be slightly different (more consistent)

---

## Issue 2: OutputRenderer Has Too Many Responsibilities

### Problem
`output-renderer.js` (479 LOC) handles three distinct concerns:
1. Text output rendering
2. Canvas graphics
3. User input handling (input fields, keypresses)

### Solution
Split into focused classes:

```
src/
  output-renderer.js    → TextRenderer (text output only)
  canvas-renderer.js    → CanvasRenderer (graphics only)
  input-handler.js      → InputHandler (input/key handling)
```

### Implementation

**TextRenderer** (~100 LOC):
```javascript
export class TextRenderer {
  constructor(container) { ... }
  clear() { ... }
  renderOutput(values) { ... }
  renderErrors(lexErrors, parseErrors, runtimeErrors) { ... }
  renderMessage(message) { ... }
  printText(value) { ... }
}
```

**CanvasRenderer** (~200 LOC):
```javascript
export class CanvasRenderer {
  constructor(container) { ... }
  createCanvas() { ... }
  setColor(hex) { ... }
  drawRect(x, y, w, h) { ... }
  drawCircle(x, y, r) { ... }
  drawLine(x1, y1, x2, y2) { ... }
  drawText(x, y, str) { ... }
  drawTriangle(...) { ... }
  clearCanvas() { ... }
  setFillMode() / setStrokeMode() { ... }
  enterFullscreen() { ... }
  getWidth() / getHeight() { ... }
}
```

**InputHandler** (~150 LOC):
```javascript
export class InputHandler {
  constructor(container) { ... }
  showInputField() { ... }
  waitForKeypress() { ... }
}
```

**OutputRenderer** (facade, ~50 LOC):
```javascript
export class OutputRenderer {
  constructor(container) {
    this.text = new TextRenderer(container);
    this.canvas = new CanvasRenderer(container);
    this.input = new InputHandler(container);
  }
  // Delegate methods to appropriate renderer
}
```

### Files Changed
- `src/output-renderer.js` - Refactor to facade
- `src/text-renderer.js` - New file
- `src/canvas-renderer.js` - New file
- `src/input-handler.js` - New file
- `src/main.js` - Update imports (or keep using facade)

### Tests
- All existing tests should pass (facade maintains API)

---

## Issue 3: main.js State Management

### Problem
`main.js` (518 LOC) mixes UI logic with execution orchestration. State transitions are spread across multiple functions.

### Solution
Extract state management into dedicated class:

```javascript
// src/state-manager.js
export class StateManager {
  constructor() {
    this.state = 'edit';  // 'edit' | 'stepping' | 'running' | 'done'
    this.listeners = [];
  }

  getState() { return this.state; }

  setState(newState) {
    const oldState = this.state;
    this.state = newState;
    this.listeners.forEach(fn => fn(newState, oldState));
  }

  onStateChange(listener) {
    this.listeners.push(listener);
  }

  // State predicates
  isEditing() { return this.state === 'edit'; }
  isStepping() { return this.state === 'stepping'; }
  isRunning() { return this.state === 'running'; }
  isDone() { return this.state === 'done'; }

  // State transitions
  startStepping() { this.setState('stepping'); }
  startRunning() { this.setState('running'); }
  finish() { this.setState('done'); }
  reset() { this.setState('edit'); }
}
```

### Files Changed
- `src/state-manager.js` - New file
- `src/main.js` - Use StateManager, simplify updateUI()

---

## Issue 4: Dead Code - Unused NodeType Export

### Problem
`NodeType` enum in `constants.js` was added for Phase 3 optimization but never used (Phase 3 was deferred).

### Solution
Remove unused export or add comment explaining future use:

```javascript
// Option A: Remove entirely
// Delete lines 14-44 from constants.js

// Option B: Keep with documentation
// Node type IDs for fast dispatch (reserved for future optimization)
// Currently unused - Phase 3 of Release 23 was deferred
export const NodeType = { ... };
```

### Recommendation
Remove it. Can be re-added if needed later.

### Files Changed
- `src/constants.js` - Remove NodeType export

---

## Issue 5: Missing Recursion Depth Limit

### Problem
No limit on recursive function calls. Deeply recursive programs could cause stack overflow.

### Solution
Add recursion depth tracking to interpreter:

```javascript
// interpreter.js
constructor(options = {}) {
  // ...
  this.callDepth = 0;
  this.maxCallDepth = options.maxCallDepth || 1000;
}

// In CallExpression handling:
if (this.callDepth >= this.maxCallDepth) {
  throw new RuntimeError(`Maximum call depth exceeded (${this.maxCallDepth})`);
}
this.callDepth++;
try {
  // ... execute function
} finally {
  this.callDepth--;
}
```

### Files Changed
- `src/interpreter.js` - Add call depth tracking
- `src/constants.js` - Add MAX_CALL_DEPTH constant

### Tests
```javascript
test('deeply recursive function hits depth limit', async ({ page }) => {
  await runFast(page, `
    function recurse(n) {
      return recurse(n + 1)
    }
    recurse(0)
  `);
  await expect(page.locator('#output')).toContainText('Maximum call depth exceeded');
});
```

---

## Issue 6: tryBuiltinCall() Performance

### Problem
Linear switch statement with 25+ cases. Each builtin call checks all cases sequentially.

### Solution
Use dispatch Map for O(1) lookup:

```javascript
// interpreter.js
constructor(options = {}) {
  // ...
  this.builtins = new Map([
    ['print', this.builtinPrint.bind(this)],
    ['num', this.builtinNum.bind(this)],
    ['random', this.builtinRandom.bind(this)],
    // ... etc
  ]);
}

async tryBuiltinCall(node) {
  const handler = this.builtins.get(node.callee);
  if (!handler) return undefined;

  const args = [];
  for (const arg of node.arguments) {
    args.push(await this.evaluate(arg));
  }
  return handler(args);
}

builtinPrint(args) {
  validateArgs(args, 1, 'print');
  this.onPrint(args[0]);
  return null;
}
// ... etc
```

### Files Changed
- `src/interpreter.js` - Refactor tryBuiltinCall()

### Benefits
- O(1) lookup instead of O(n) switch
- Each builtin is a focused method
- Easier to add new builtins
- More testable

---

## Issue 7: Missing Architecture Documentation

### Problem
No high-level documentation explaining system design.

### Solution
Create `docs/architecture.md`:

```markdown
# Tiny Development Environment Architecture

## Overview
A browser-based interpreter for the Tiny programming language with
step-through debugging and visualization.

## Pipeline
```
Source Code → Lexer → Tokens → Parser → AST → Interpreter → Output
                ↓         ↓        ↓           ↓
            Scanner   ParserRdr  ASTRdr    MemoryRdr
                        ↓
                   Visualizer
```

## Layers

### 1. Parsing Layer
- **Lexer** - Tokenizes source code
- **Scanner** - Character-by-character stepping for visualization
- **Parser** - Builds AST from tokens

### 2. Execution Layer
- **Interpreter** - Evaluates AST nodes
- **Runtime** - Environment, functions, classes, errors

### 3. Rendering Layer
- **ASTRenderer** - Visualizes AST tree
- **MemoryRenderer** - Shows variable state
- **OutputRenderer** - Text/graphics output
- **ParserRenderer** - Token display
- **CodeVisualizer** - Source highlighting

### 4. Orchestration
- **main.js** - Wires everything together

## Key Design Decisions
1. Callback-based interpreter for visualization hooks
2. Async execution for animation support
3. Canvas-based graphics for sandboxed output
```

### Files Changed
- `docs/architecture.md` - New file

---

## Implementation Order

1. [ ] Issue 4: Remove unused NodeType export (trivial)
2. [ ] Issue 1: Extract argument validation helpers
3. [ ] Issue 5: Add recursion depth limit
4. [ ] Issue 6: Refactor tryBuiltinCall() to use Map
5. [ ] Issue 2: Split OutputRenderer (largest change)
6. [ ] Issue 3: Extract StateManager
7. [ ] Issue 7: Add architecture documentation

## File Changes Summary

| File | Action |
|------|--------|
| src/constants.js | Remove NodeType, add MAX_CALL_DEPTH |
| src/runtime.js | Add validateArgs, validateArgTypes |
| src/interpreter.js | Use helpers, add depth limit, refactor builtins |
| src/output-renderer.js | Refactor to facade |
| src/text-renderer.js | New file |
| src/canvas-renderer.js | New file |
| src/input-handler.js | New file |
| src/state-manager.js | New file |
| src/main.js | Use StateManager |
| docs/architecture.md | New file |

## Success Criteria

- All 328 tests pass
- No new test failures
- Code quality score improves from 8/10 to 9/10
- Argument validation has single source of truth
- OutputRenderer responsibilities are separated
- Recursion depth is limited
- Architecture is documented
