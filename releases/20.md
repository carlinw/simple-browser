# Release 20: Classes and Objects

> Follow CLAUDE.md - do not implement until user approves complete release plan.

## Goals

Add object-oriented programming with classes, enabling heap visualization and teaching reference semantics.

---

## Language Syntax (this release)

### New Keywords
- `class` - define a class with fields and methods
- `new` - create an instance (allocate on heap)
- `this` - reference to current instance inside methods

### Grammar

```
classDeclaration = "class" IDENTIFIER "{" classBody "}"
classBody = (field | method)*
field = IDENTIFIER ","
method = IDENTIFIER "(" parameters? ")" block

newExpression = "new" IDENTIFIER "(" arguments? ")"
memberAccess = expression "." IDENTIFIER
```

---

## New Features

### 1. Class Declaration

Define a class with fields and methods:

```
class Person {
    name,
    age,

    greet() {
        print("Hi, I'm " + this.name)
    },

    birthday() {
        this.age = this.age + 1
        return this.age
    }
}
```

**Rules:**
- Fields are listed by name, separated by commas
- Fields must come before methods
- Methods are functions that have access to `this`
- Class names should start with uppercase (convention, not enforced)

### 2. Creating Instances with `new`

```
let p = new Person("Connor", 25)
```

**Rules:**
- Arguments are assigned to fields in declaration order
- Number of arguments must match number of fields
- Returns a reference to the heap-allocated object

### 3. Field Access

```
print(p.name)    // "Connor"
print(p.age)     // 25
```

### 4. Field Mutation

```
p.age = 26
p.name = "Connor W"
```

### 5. Method Calls

```
p.greet()        // prints: Hi, I'm Connor
let newAge = p.birthday()  // returns 26
```

### 6. The `this` Keyword

Inside methods, `this` refers to the instance:

```
class Counter {
    count,

    increment() {
        this.count = this.count + 1
    },

    get() {
        return this.count
    }
}

let c = new Counter(0)
c.increment()
c.increment()
print(c.get())  // 2
```

---

## Reference Semantics (Key Educational Concept)

This is the main teaching moment - objects are references:

```
class Box {
    value
}

let a = new Box(10)
let b = a          // b points to SAME object

b.value = 99
print(a.value)     // 99 (!)
```

**What students learn:**
- `a` and `b` are both references (arrows) to the same heap location
- Changing `b.value` changes `a.value` because they're the same object
- This is different from primitives: `let x = 5; let y = x; y = 10` leaves `x` unchanged

---

## Implementation

### Lexer Changes

Add new keywords to `KEYWORDS` set:

```javascript
const KEYWORDS = new Set([
    // ... existing keywords ...
    'class',
    'new',
    'this'
]);
```

Add new token types:

```javascript
// In tokenize(), handle 'class', 'new', 'this' as keywords
// They'll be tokenized as { type: 'CLASS' }, { type: 'NEW' }, { type: 'THIS' }
```

### Parser Changes

#### New AST Nodes

```javascript
// ClassDeclaration
{
    type: 'ClassDeclaration',
    name: 'Person',
    fields: ['name', 'age'],
    methods: [
        {
            type: 'MethodDeclaration',
            name: 'greet',
            params: [],
            body: { type: 'Block', statements: [...] }
        }
    ]
}

// NewExpression
{
    type: 'NewExpression',
    className: 'Person',
    arguments: [Expression, Expression]
}

// ThisExpression
{
    type: 'ThisExpression'
}

// MemberExpression (already exists for arrays, extend for objects)
{
    type: 'MemberExpression',
    object: Expression,
    property: 'name',      // string for dot access
    computed: false        // false for dot, true for bracket
}
```

#### Parser Methods

```javascript
// Add to parseStatement()
if (this.check('CLASS')) {
    return this.parseClassDeclaration();
}

parseClassDeclaration() {
    this.consume('CLASS', "Expected 'class'");
    const name = this.consume('IDENTIFIER', "Expected class name").value;
    this.consume('LBRACE', "Expected '{' after class name");

    const fields = [];
    const methods = [];

    // Parse fields first (identifiers followed by comma)
    while (this.check('IDENTIFIER') && this.checkNext('COMMA')) {
        fields.push(this.consume('IDENTIFIER').value);
        this.consume('COMMA');
    }
    // Check for last field without trailing comma before method
    if (this.check('IDENTIFIER') && this.checkNext('LPAREN')) {
        // This is a method, not a field
    } else if (this.check('IDENTIFIER')) {
        fields.push(this.consume('IDENTIFIER').value);
        if (this.check('COMMA')) this.advance(); // optional trailing comma
    }

    // Parse methods
    while (!this.check('RBRACE') && !this.isAtEnd()) {
        const methodName = this.consume('IDENTIFIER', "Expected method name").value;
        this.consume('LPAREN', "Expected '(' after method name");
        const params = this.parseParameters();
        this.consume('RPAREN', "Expected ')' after parameters");
        const body = this.parseBlock();
        methods.push({
            type: 'MethodDeclaration',
            name: methodName,
            params,
            body
        });
        if (this.check('COMMA')) this.advance(); // optional comma between methods
    }

    this.consume('RBRACE', "Expected '}' after class body");

    return {
        type: 'ClassDeclaration',
        name,
        fields,
        methods
    };
}

// Add to parsePrimary()
if (this.check('NEW')) {
    return this.parseNewExpression();
}

if (this.check('THIS')) {
    this.advance();
    return { type: 'ThisExpression' };
}

parseNewExpression() {
    this.consume('NEW', "Expected 'new'");
    const className = this.consume('IDENTIFIER', "Expected class name").value;
    this.consume('LPAREN', "Expected '(' after class name");
    const args = this.parseArguments();
    this.consume('RPAREN', "Expected ')' after arguments");

    return {
        type: 'NewExpression',
        className,
        arguments: args
    };
}

// Extend parsePostfix() to handle dot access
parsePostfix() {
    let expr = this.parsePrimary();

    while (true) {
        if (this.check('LPAREN')) {
            // Function call
            expr = this.parseCall(expr);
        } else if (this.check('LBRACKET')) {
            // Array index
            expr = this.parseIndex(expr);
        } else if (this.check('DOT')) {
            // Member access (NEW)
            this.advance();
            const property = this.consume('IDENTIFIER', "Expected property name").value;
            expr = {
                type: 'MemberExpression',
                object: expr,
                property,
                computed: false
            };
        } else {
            break;
        }
    }

    return expr;
}
```

### Runtime Changes

#### New TinyClass and TinyInstance Classes

```javascript
// In runtime.js

class TinyClass {
    constructor(name, fields, methods) {
        this.name = name;
        this.fields = fields;      // Array of field names
        this.methods = methods;    // Map of method name -> MethodDeclaration
    }
}

class TinyInstance {
    constructor(klass) {
        this.klass = klass;
        this.fields = new Map();   // Field name -> value
    }

    get(name) {
        if (this.fields.has(name)) {
            return this.fields.get(name);
        }
        const method = this.klass.methods.get(name);
        if (method) {
            // Return bound method
            return new TinyBoundMethod(this, method);
        }
        throw new RuntimeError(`Undefined property: ${name}`);
    }

    set(name, value) {
        this.fields.set(name, value);
    }
}

class TinyBoundMethod {
    constructor(instance, method) {
        this.instance = instance;
        this.method = method;
    }
}
```

### Interpreter Changes

#### Handle ClassDeclaration

```javascript
// In execute()
case 'ClassDeclaration': {
    const methods = new Map();
    for (const method of node.methods) {
        methods.set(method.name, method);
    }
    const klass = new TinyClass(node.name, node.fields, methods);
    this.environment.define(node.name, klass);
    return;
}
```

#### Handle NewExpression

```javascript
// In evaluate()
case 'NewExpression': {
    const klass = this.environment.get(node.className);
    if (!(klass instanceof TinyClass)) {
        throw new RuntimeError(`${node.className} is not a class`);
    }

    const instance = new TinyInstance(klass);

    // Evaluate arguments
    const args = [];
    for (const arg of node.arguments) {
        args.push(await this.evaluate(arg));
    }

    // Check argument count matches field count
    if (args.length !== klass.fields.length) {
        throw new RuntimeError(
            `${klass.name} expects ${klass.fields.length} arguments, got ${args.length}`
        );
    }

    // Initialize fields
    for (let i = 0; i < klass.fields.length; i++) {
        instance.set(klass.fields[i], args[i]);
    }

    return instance;
}
```

#### Handle ThisExpression

```javascript
// In evaluate()
case 'ThisExpression': {
    return this.environment.get('this');
}
```

#### Handle MemberExpression (Get)

```javascript
// In evaluate()
case 'MemberExpression': {
    const object = await this.evaluate(node.object);

    if (object instanceof TinyInstance) {
        return object.get(node.property);
    }

    // Handle arrays (existing code)
    if (Array.isArray(object) && node.computed) {
        // ... existing array index code ...
    }

    throw new RuntimeError('Only instances have properties');
}
```

#### Handle MemberExpression (Set) in Assignment

```javascript
// In execute() for Assignment
case 'AssignmentStatement': {
    const value = await this.evaluate(node.value);

    if (node.target.type === 'MemberExpression' && !node.target.computed) {
        // Object field assignment
        const object = await this.evaluate(node.target.object);
        if (!(object instanceof TinyInstance)) {
            throw new RuntimeError('Only instances have properties');
        }
        object.set(node.target.property, value);
        return;
    }

    // ... existing assignment code ...
}
```

#### Handle Bound Method Calls

```javascript
// In evaluate() for CallExpression
case 'CallExpression': {
    const callee = await this.evaluate(node.callee);

    if (callee instanceof TinyBoundMethod) {
        const args = [];
        for (const arg of node.arguments) {
            args.push(await this.evaluate(arg));
        }

        // Create new environment with 'this' bound
        const methodEnv = new Environment(this.environment);
        methodEnv.define('this', callee.instance);

        // Bind parameters
        for (let i = 0; i < callee.method.params.length; i++) {
            methodEnv.define(callee.method.params[i], args[i] ?? null);
        }

        // Execute method body
        const previousEnv = this.environment;
        this.environment = methodEnv;
        try {
            await this.execute(callee.method.body);
            return null;
        } catch (e) {
            if (e instanceof ReturnValue) {
                return e.value;
            }
            throw e;
        } finally {
            this.environment = previousEnv;
        }
    }

    // ... existing function call code ...
}
```

### Memory Visualization

Update `memory-renderer.js` to display objects:

```javascript
renderValue(value) {
    if (value instanceof TinyInstance) {
        return this.renderInstance(value);
    }
    // ... existing code ...
}

renderInstance(instance) {
    const div = document.createElement('div');
    div.className = 'memory-object';

    const header = document.createElement('div');
    header.className = 'memory-object-header';
    header.textContent = instance.klass.name;
    div.appendChild(header);

    const fields = document.createElement('div');
    fields.className = 'memory-object-fields';

    for (const [name, value] of instance.fields) {
        const field = document.createElement('div');
        field.className = 'memory-field';
        field.innerHTML = `<span class="field-name">${name}:</span> `;
        field.appendChild(this.renderValue(value));
        fields.appendChild(field);
    }

    div.appendChild(fields);
    return div;
}
```

---

## Tests

### tests/classes.spec.js (NEW)

#### Class Declaration
1. **"class declaration creates class"**
   - Run: `class Foo { x } print("ok")`
   - Output: `ok`

2. **"class with multiple fields"**
   - Run: `class Point { x, y } print("ok")`
   - Output: `ok`

3. **"class with methods"**
   - Run: `class Foo { x, get() { return this.x } } print("ok")`
   - Output: `ok`

#### Instance Creation
4. **"new creates instance"**
   - Run: `class Box { value } let b = new Box(42) print(b.value)`
   - Output: `42`

5. **"new with multiple fields"**
   - Run: `class Point { x, y } let p = new Point(10, 20) print(p.x) print(p.y)`
   - Output: `10` then `20`

6. **"new with wrong argument count throws error"**
   - Run: `class Box { value } let b = new Box(1, 2)`
   - Error: `expects 1 arguments, got 2`

7. **"new on non-class throws error"**
   - Run: `let x = 5 let b = new x()`
   - Error: `is not a class`

#### Field Access
8. **"field access returns value"**
   - Run: `class Box { value } let b = new Box(42) print(b.value)`
   - Output: `42`

9. **"field mutation works"**
   - Run: `class Box { value } let b = new Box(10) b.value = 99 print(b.value)`
   - Output: `99`

10. **"undefined field throws error"**
    - Run: `class Box { value } let b = new Box(10) print(b.missing)`
    - Error: `Undefined property`

#### Methods
11. **"method call works"**
    - Run: `class Greeter { name, greet() { print("Hi " + this.name) } } let g = new Greeter("World") g.greet()`
    - Output: `Hi World`

12. **"method can return value"**
    - Run: `class Box { value, get() { return this.value } } let b = new Box(42) print(b.get())`
    - Output: `42`

13. **"method can modify fields"**
    - Run: `class Counter { n, inc() { this.n = this.n + 1 } } let c = new Counter(0) c.inc() c.inc() print(c.n)`
    - Output: `2`

14. **"method with parameters"**
    - Run: `class Calc { value, add(x) { this.value = this.value + x } } let c = new Calc(10) c.add(5) print(c.value)`
    - Output: `15`

#### Reference Semantics
15. **"assignment copies reference, not value"**
    - Run: `class Box { value } let a = new Box(10) let b = a b.value = 99 print(a.value)`
    - Output: `99`

16. **"objects in arrays"**
    - Run: `class Point { x, y } let points = [new Point(1, 2), new Point(3, 4)] print(points[0].x) print(points[1].y)`
    - Output: `1` then `4`

#### This Binding
17. **"this refers to instance"**
    - Run: `class Self { value, getThis() { return this } } let s = new Self(42) let t = s.getThis() print(t.value)`
    - Output: `42`

18. **"this outside method throws error"**
    - Run: `print(this)`
    - Error: `Undefined variable: this`

#### Nested Objects
19. **"nested object access"**
    - Run: `class Inner { value } class Outer { inner } let o = new Outer(new Inner(42)) print(o.inner.value)`
    - Output: `42`

20. **"chained method calls"**
    - Run: `class Builder { value, set(v) { this.value = v return this } } let b = new Builder(0) b.set(10).set(20) print(b.value)`
    - Output: `20`

---

## File Changes

```
src/
  lexer.js           # Add 'class', 'new', 'this' keywords
  parser.js          # Add class/new/this parsing, dot access
  runtime.js         # Add TinyClass, TinyInstance, TinyBoundMethod
  interpreter.js     # Handle new AST nodes
  memory-renderer.js # Render objects in memory view
styles/
  main.css           # Styling for object visualization
tests/
  classes.spec.js    # NEW - 20 tests
```

---

## Deliverables

### Lexer
- [ ] Add `class` keyword
- [ ] Add `new` keyword
- [ ] Add `this` keyword
- [ ] Add `DOT` token type

### Parser
- [ ] Parse ClassDeclaration
- [ ] Parse NewExpression
- [ ] Parse ThisExpression
- [ ] Parse MemberExpression with dot notation

### Runtime
- [ ] Create TinyClass class
- [ ] Create TinyInstance class
- [ ] Create TinyBoundMethod class

### Interpreter
- [ ] Execute ClassDeclaration
- [ ] Evaluate NewExpression
- [ ] Evaluate ThisExpression
- [ ] Evaluate MemberExpression (get)
- [ ] Handle MemberExpression assignment (set)
- [ ] Handle bound method calls with `this`

### Memory Visualization
- [ ] Render TinyInstance in memory view
- [ ] Show class name and fields
- [ ] Style object display

### Language Help
- [ ] Add Classes section
- [ ] Document class/new/this keywords
- [ ] Add examples

### Tests
- [ ] Create tests/classes.spec.js with 20 tests
- [ ] All tests passing

---

## Example Programs

### Simple Counter
```
class Counter {
    count,

    increment() {
        this.count = this.count + 1
    },

    decrement() {
        this.count = this.count - 1
    },

    get() {
        return this.count
    }
}

let c = new Counter(0)
c.increment()
c.increment()
c.increment()
print(c.get())  // 3
```

### Point with Distance
```
class Point {
    x,
    y,

    distanceFromOrigin() {
        return (this.x * this.x + this.y * this.y)
    },

    move(dx, dy) {
        this.x = this.x + dx
        this.y = this.y + dy
    }
}

let p = new Point(3, 4)
print(p.distanceFromOrigin())  // 25 (would be 5 with sqrt)
p.move(1, 1)
print(p.x)  // 4
print(p.y)  // 5
```

### Linked List Node
```
class Node {
    value,
    next,

    append(val) {
        if (this.next equals null) {
            this.next = new Node(val, null)
        } else {
            this.next.append(val)
        }
    },

    printAll() {
        print(this.value)
        if (not (this.next equals null)) {
            this.next.printAll()
        }
    }
}

let list = new Node(1, null)
list.append(2)
list.append(3)
list.printAll()  // 1, 2, 3
```

---

## Status

**PLANNING** - Awaiting user approval
