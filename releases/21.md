# Release 21: Code Quality Cleanup + Objects

## Status: COMPLETE

## Overview

1. Address code quality issues identified in Release 20 analysis
2. Add objects/classes to the language

---

## Code Quality Summary

**Strengths:**
- Clean separation of concerns (Lexer → Parser → Interpreter)
- Consistent patterns across renderers
- Good naming conventions
- No circular dependencies
- Custom error classes with context

**Issues Found:**

| Category | Count | Notable Items |
|----------|-------|---------------|
| Dead code | 2 | `reference.js` entirely unused, `renderLegacy()` never called |
| Potential bugs | 3 | Infinite loop risk in lexer, null guard missing in parser, event listener leak |
| Code smells | 4 | Large files (interpreter 617 LOC, parser 596 LOC), token mutation, duplicate `peekNext()` |
| Inconsistencies | 2 | Mixed module formats, inconsistent error returns |

The codebase is in good shape overall. The most actionable items for a future release would be:
1. Delete `reference.js` (unused)
2. Fix the infinite recursion risk in `lexer.js:172-179`
3. Remove the unused `renderLegacy()` method

---

## Proposed Tasks

### Priority 1: Dead Code Removal

- [ ] Delete `src/reference.js` - entire file is unused
- [ ] Remove `renderLegacy()` from `memory-renderer.js:128-152`

### Priority 2: Bug Fixes

- [ ] Fix infinite loop risk in `lexer.js:172-179` - invalid char error leads to recursive `nextToken()` call
- [ ] Add null guard in `parser.js:86-88` - `getTitle()` doesn't check for null token
- [ ] Fix event listener leak in `output-renderer.js:140-154` - `keydown` listener may not be removed on error paths

### Priority 3: Code Smells (Deferred)

These are lower priority and can be addressed later:

- `interpreter.js` - 617 lines, consider splitting
- `parser.js` - 596 lines, consider splitting
- `scanner.js:276-277` - mutates token value after adding to array
- `lexer.js:223-227, 371-374` - `peekNext()` defined twice

### Priority 4: Inconsistencies (Deferred)

- `reference.js` - has CommonJS export alongside ES modules (will be deleted anyway)
- `lexer.js` - `readString()` returns null on error vs token object

---

## Feature: Objects/Classes

### Why Objects?

Objects let you work with complex things by building them from simpler things, and those from even simpler things - all the way down to primitives.

- **Compose** - Bundle variables into concepts (Player = name + x + y + health)
- **Nest** - Build bigger concepts from smaller ones (Team has Players, Game has Teams)
- **Pass around** - One reference handles the whole bundle
- **Organize** - Code lives with the data it operates on

### Syntax

```
class Player {
    name,
    x,
    y,

    move(dx, dy) {
        this.x = this.x + dx
        this.y = this.y + dy
    }
}

let p = new Player("Connor", 100, 200)
p.move(10, 0)
print(p.x)  // 110
```

### Keywords

- `class` - Define a class
- `new` - Create an instance
- `this` - Reference to current instance inside methods

### Memory Management

No explicit GC or reference counting. JavaScript handles it underneath.

### Implementation Plan

**Lexer changes:**
- Add keywords: `class`, `new`, `this`
- Add tokens: `DOT` (for property access), `COMMA` (for field lists)

**Parser changes:**
- `parseClassDeclaration()` - Parse class with fields and methods
- `parseNewExpression()` - Parse `new ClassName(args)`
- `parseMemberAccess()` - Parse `obj.field` and `obj.method()`
- Update expression parsing for `this`

**Interpreter changes:**
- `TinyClass` - Store class definition (fields, methods)
- `TinyInstance` - Store instance data (field values, class reference)
- Handle property get/set on instances
- Handle method calls with `this` binding

**AST nodes to add:**
- `ClassDeclaration` - name, fields[], methods[]
- `NewExpression` - className, arguments[]
- `MemberAccess` - object, property
- `ThisExpression`

### Example Programs to Add/Update

- Simple class example (Point or Player)
- Game example using classes (refactor Snake or Pong to use Player class)
