# Release 23: Interpreter Performance Optimizations

## Status: COMPLETE

## Goal
Significantly improve interpreter execution speed for Run mode by eliminating async overhead, skipping visualization callbacks, and optimizing hot paths.

## Current Performance Issues

| Issue | Impact | Description |
|-------|--------|-------------|
| Async everywhere | HIGH | Every `execute()` and `evaluate()` is async even when no async ops needed |
| Callback overhead | MEDIUM | `enterNode()`/`exitNode()` called for every node, even in Run mode |
| String type dispatch | LOW-MED | `switch(node.type)` uses string comparisons |
| Scope chain lookup | MEDIUM | Variable access walks parent chain recursively |

## Implementation Plan

### Phase 1: Synchronous Fast Path

Add synchronous versions of `execute` and `evaluate` for Run mode when no async builtins are used.

**File:** `src/interpreter.js`

```javascript
// New property to track if program uses async builtins
this.needsAsync = false;

// Check AST for async builtins before execution
checkForAsyncBuiltins(ast) {
  // Walk AST looking for: input(), key(), sleep()
  // Set this.needsAsync = true if found
}

// Main entry - choose sync or async path
async interpret(ast) {
  this.checkForAsyncBuiltins(ast);

  if (this.stepDelay === 0 && !this.needsAsync) {
    return this.interpretSync(ast);
  }
  return this.interpretAsync(ast);
}

// Synchronous execution (no await, no Promise overhead)
interpretSync(ast) {
  const results = [];
  for (const statement of ast.statements) {
    this.checkStopped();
    const result = this.executeSync(statement);
    if (result !== undefined && result !== null) {
      results.push(result);
    }
  }
  return { output: results, errors: [] };
}

executeSync(node) {
  // Same logic as execute() but without async/await
  // No enterNode/exitNode calls (visualization disabled)
}

evaluateSync(node) {
  // Same logic as evaluate() but without async/await
}
```

### Phase 2: Skip Callbacks in Run Mode

Only call visualization hooks when `stepDelay > 0`.

**File:** `src/interpreter.js`

```javascript
// Before (current):
async enterNode(node) {
  this.onNodeEnter(node);
  if (this.stepDelay > 0) {
    await this.delay(this.stepDelay);
  }
}

// After:
async enterNode(node) {
  if (this.stepDelay > 0) {
    this.onNodeEnter(node);
    await this.delay(this.stepDelay);
  }
}

// Also guard onVariableChange, onCallStart, onCallEnd
// Only call these when in debug/step mode
```

### Phase 3: Numeric Type IDs

Replace string-based node type dispatch with numeric IDs for faster switching.

**File:** `src/constants.js`

```javascript
// Node type constants
export const NodeType = {
  // Statements
  Program: 0,
  LetStatement: 1,
  AssignStatement: 2,
  IfStatement: 3,
  WhileStatement: 4,
  Block: 5,
  FunctionDeclaration: 6,
  ReturnStatement: 7,
  ExpressionStatement: 8,
  IndexAssignStatement: 9,
  ClassDeclaration: 10,
  MemberAssignStatement: 11,

  // Expressions
  NumberLiteral: 20,
  StringLiteral: 21,
  BooleanLiteral: 22,
  Identifier: 23,
  BinaryExpression: 24,
  UnaryExpression: 25,
  CallExpression: 26,
  ArrayLiteral: 27,
  IndexExpression: 28,
  ThisExpression: 29,
  NewExpression: 30,
  MemberExpression: 31,
  MethodCall: 32,
};
```

**File:** `src/parser.js`

```javascript
import { NodeType } from './constants.js';

// Change all node creation to include typeId:
return {
  type: 'NumberLiteral',      // Keep for debugging/display
  typeId: NodeType.NumberLiteral,  // Add for fast dispatch
  value: token.value,
  token: token
};
```

**File:** `src/interpreter.js`

```javascript
import { NodeType } from './constants.js';

evaluateSync(node) {
  switch (node.typeId) {
    case NodeType.NumberLiteral:
      return node.value;
    case NodeType.StringLiteral:
      return node.value;
    case NodeType.BinaryExpression:
      return this.evaluateBinarySync(node);
    // ...
  }
}
```

### Phase 4: Optimized Variable Lookup

Flatten environment for faster variable access in tight loops.

**File:** `src/runtime.js`

```javascript
export class Environment {
  constructor(parent = null) {
    this.values = new Map();
    this.parent = parent;
    // Cache depth for debugging
    this.depth = parent ? parent.depth + 1 : 0;
  }

  // Optimized get - avoid recursion for common case
  get(name) {
    let env = this;
    while (env) {
      if (env.values.has(name)) {
        return env.values.get(name);
      }
      env = env.parent;
    }
    throw new RuntimeError(`Undefined variable: ${name}`);
  }

  // Optimized assign - avoid recursion
  assign(name, value) {
    let env = this;
    while (env) {
      if (env.values.has(name)) {
        env.values.set(name, value);
        return;
      }
      env = env.parent;
    }
    throw new RuntimeError(`Undefined variable: ${name}`);
  }
}
```

## File Changes

| File | Changes |
|------|---------|
| src/constants.js | Add NodeType enum |
| src/parser.js | Add typeId to all nodes |
| src/interpreter.js | Add sync execution path, guard callbacks, use typeId |
| src/runtime.js | Iterative scope chain lookup |
| src/lexer.js | No changes |
| src/scanner.js | No changes |

## Testing Strategy

### Performance Tests

Create benchmark test to measure improvement:

**File:** `tests/performance.spec.js`

```javascript
const { test, expect } = require('@playwright/test');

test('loop performance benchmark', async ({ page }) => {
  await page.goto('/');

  const code = `
    let sum = 0
    let i = 0
    while (i < 10000) {
      sum = sum + i
      i = i + 1
    }
    print(sum)
  `;

  await page.fill('#code-editor', code);

  const start = Date.now();
  await page.click('#run-btn');
  await expect(page.locator('#output')).toContainText('49995000');
  const elapsed = Date.now() - start;

  console.log(`Loop benchmark: ${elapsed}ms`);
  // Should complete in under 2 seconds
  expect(elapsed).toBeLessThan(2000);
});

test('recursive performance benchmark', async ({ page }) => {
  await page.goto('/');

  const code = `
    function fib(n) {
      if (n < 2) { return n }
      return fib(n - 1) + fib(n - 2)
    }
    print(fib(20))
  `;

  await page.fill('#code-editor', code);

  const start = Date.now();
  await page.click('#run-btn');
  await expect(page.locator('#output')).toContainText('6765');
  const elapsed = Date.now() - start;

  console.log(`Fibonacci benchmark: ${elapsed}ms`);
  expect(elapsed).toBeLessThan(3000);
});
```

### Regression Tests

All existing tests must pass - the optimization should be invisible to users.

## Implementation Order

1. [x] Phase 4: Iterative scope lookup (simplest, no API changes)
2. [x] Phase 2: Guard callbacks in Run mode
3. [ ] ~~Phase 3: Add NodeType enum and typeId to parser~~ (deferred - not needed)
4. [ ] ~~Phase 1: Add sync execution path~~ (deferred - not needed)
5. [x] Add performance benchmark tests
6. [x] Run full test suite (326 tests pass)

## Expected Improvements

| Optimization | Expected Speedup |
|-------------|------------------|
| Sync execution path | 3-5x for simple programs |
| Skip callbacks | 1.5-2x |
| Numeric type IDs | 1.2-1.5x |
| Iterative lookup | 1.1-1.3x for nested scopes |
| **Combined** | **5-10x for Run mode** |

## Actual Results (Implemented 2024-12-15)

Only Phases 2 and 4 were needed to achieve target performance:

| Benchmark | Before | After | Speedup |
|-----------|--------|-------|---------|
| Tight loop (10k iterations) | 883ms | **94ms** | **9.4x** |
| Nested loops (100x100) | 903ms | **78ms** | **11.6x** |
| Fibonacci(20) recursive | 2,172ms | **110ms** | **19.7x** |
| Array operations (1k) | 201ms | **39ms** | **5.2x** |
| String concatenation (500) | 99ms | **39ms** | **2.5x** |
| Function calls (1k) | 187ms | **49ms** | **3.8x** |
| Nested scope lookups (1k) | 164ms | **38ms** | **4.3x** |
| Class methods (500) | 122ms | **33ms** | **3.7x** |
| Arithmetic expressions (2k) | 294ms | **47ms** | **6.3x** |
| Conditionals in loop (2k) | 333ms | **66ms** | **5.0x** |

**Average speedup: ~7x**

**Key insight:** The visualization callback overhead (enterNode/exitNode being called for every AST node even in Run mode) was the main bottleneck. Simply guarding these calls with `if (this.stepDelay > 0)` achieved **4-20x speedup**. The most dramatic improvement is recursive function calls (Fibonacci) at nearly **20x faster**, because each recursive call was triggering visualization callbacks that are now skipped in Run mode.

Phases 3 (numeric type IDs) and 1 (sync execution path) were deferred as unnecessary - the target performance was exceeded with minimal code changes.

## Baseline Performance Measurements

Measured on 2024-12-15 before any optimizations:

| Benchmark | Code | Time | Ops/sec |
|-----------|------|------|---------|
| Tight loop (10k) | `while (i < 10000) { sum = sum + i; i = i + 1 }` | **883ms** | ~11,300 |
| Nested loops (100x100) | `while (i < 100) { while (j < 100) { sum = sum + 1 } }` | **903ms** | ~11,000 |
| Fibonacci(20) | `function fib(n) { if (n < 2) { return n } return fib(n-1) + fib(n-2) }` | **2,172ms** | ~10,000 calls |
| Array ops (1k) | `while (i < 1000) { arr[i % 10] = arr[i % 10] + 1 }` | **201ms** | ~5,000 |
| String concat (500) | `while (i < 500) { s = s + "x" }` | **99ms** | ~5,000 |
| Function calls (1k) | `while (i < 1000) { sum = add(sum, i) }` | **187ms** | ~5,300 |
| Nested scope (1k) | `function incrementOuter() { outer = outer + 1 }` in loop | **164ms** | ~6,100 |
| Class methods (500) | `while (i < 500) { c.increment() }` | **122ms** | ~4,100 |
| Arithmetic (2k) | `while (i < 2000) { result = (i * 2 + 3 - 1) / 2 }` | **294ms** | ~6,800 |
| Conditionals (2k) | `while (i < 2000) { if (i % 2 equals 0) { even = even + 1 } }` | **333ms** | ~6,000 |

### Benchmark Test Code

```javascript
// tests/performance.spec.js - Full benchmark code for reproducibility

// Tight loop (10k iterations)
let sum = 0
let i = 0
while (i < 10000) {
  sum = sum + i
  i = i + 1
}
print(sum)  // 49995000

// Nested loops (100x100)
let sum = 0
let i = 0
while (i < 100) {
  let j = 0
  while (j < 100) {
    sum = sum + 1
    j = j + 1
  }
  i = i + 1
}
print(sum)  // 10000

// Fibonacci recursive
function fib(n) {
  if (n < 2) { return n }
  return fib(n - 1) + fib(n - 2)
}
print(fib(20))  // 6765

// Array operations (1k)
let arr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
let i = 0
while (i < 1000) {
  arr[i % 10] = arr[i % 10] + 1
  i = i + 1
}
print(arr[0])  // 100

// String concatenation (500)
let s = ""
let i = 0
while (i < 500) {
  s = s + "x"
  i = i + 1
}
print(s.length())  // 500

// Function calls (1k)
function add(a, b) {
  return a + b
}
let sum = 0
let i = 0
while (i < 1000) {
  sum = add(sum, i)
  i = i + 1
}
print(sum)  // 499500

// Nested scope lookups (1k)
let outer = 0
function incrementOuter() {
  outer = outer + 1
}
let i = 0
while (i < 1000) {
  incrementOuter()
  i = i + 1
}
print(outer)  // 1000

// Class methods (500)
class Counter {
  value,
  increment() {
    this.value = this.value + 1
  }
  get() {
    return this.value
  }
}
let c = new Counter(0)
let i = 0
while (i < 500) {
  c.increment()
  i = i + 1
}
print(c.get())  // 500

// Arithmetic expressions (2k)
let result = 0
let i = 0
while (i < 2000) {
  result = (i * 2 + 3 - 1) / 2
  i = i + 1
}
print(result)  // 2000

// Conditionals in loop (2k)
let even = 0
let odd = 0
let i = 0
while (i < 2000) {
  if (i % 2 equals 0) {
    even = even + 1
  } else {
    odd = odd + 1
  }
  i = i + 1
}
print(even)  // 1000
```

## Notes

- Debug mode and Step mode remain unchanged (async with callbacks)
- All optimizations are internal - no language changes
- Existing tests should all pass without modification
- Performance tests added for regression prevention
