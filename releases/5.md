# Release 5: AST Visualization

> Follow CLAUDE.md - do not implement until user approves complete release plan.

## Code Quality Analysis (from Release 4)

**Current codebase:** 2,912 lines across 13 files (7 src, 4 tests, 1 css, 1 html)

### Source Files
| File | Lines | Status |
|------|-------|--------|
| scanner.js | 398 | OK - state machine is inherently complex |
| lexer.js | 384 | OK |
| parser.js | 334 | OK - clean recursive descent |
| main.js | 282 | ⚠️ `renderScanState` (78 lines) and `runAll` (75 lines) are too long |
| reference.js | 117 | OK |
| visualizer.js | 101 | OK |
| examples.js | 59 | OK |

### Test Files
| File | Lines | Tests | Status |
|------|-------|-------|--------|
| lexer-viz.spec.js | 346 | 23 | OK |
| parser.spec.js | 237 | 20 | OK |
| lexer.spec.js | 140 | 13 | OK |
| ui.spec.js | 49 | 7 | OK |

### Issues to Address

1. **Duplicate code:** `isDigit()`, `isAlpha()`, `isAlphaNumeric()` exist in both lexer.js and scanner.js
   - **Recommendation:** Extract to shared `src/utils.js` in a future refactoring release

2. **Long functions in main.js:**
   - `renderScanState()` - 78 lines
   - `runAll()` - 75 lines
   - **Recommendation:** Extract rendering helpers in this release

3. **CSS file growing:** 420 lines
   - **Recommendation:** Consider splitting by feature if it grows much more

### Deferred to Future Release
- Refactor duplicate character-checking methods (low priority - code works)

---

## Goal

Add interactive visualization of the Abstract Syntax Tree. Connor can see how the parser organizes code into a tree structure, making the relationship between syntax and meaning visible.

The visualization will:
- Display the AST as an interactive tree
- Allow expanding/collapsing nodes
- Highlight node types with colors
- Show the connection between tokens and AST nodes

## Features

### AST Tree View

Replace JSON output with a visual tree:

```
Program
├── LetStatement
│   ├── name: "x"
│   └── value: NumberLiteral
│       └── value: 42
├── LetStatement
│   ├── name: "y"
│   └── value: BinaryExpression
│       ├── operator: "+"
│       ├── left: Identifier
│       │   └── name: "x"
│       └── right: NumberLiteral
│           └── value: 1
└── PrintStatement
    └── value: Identifier
        └── name: "y"
```

### Visual Design

**Node Types with Colors:**
| Node Type | Color | Description |
|-----------|-------|-------------|
| Program | Gray | Root node |
| LetStatement | Blue | Variable declarations |
| AssignStatement | Blue | Assignments |
| PrintStatement | Green | Output |
| IfStatement | Purple | Conditionals |
| WhileStatement | Purple | Loops |
| Block | Gray | Code blocks |
| BinaryExpression | Orange | Operations |
| Identifier | Teal | Variable references |
| NumberLiteral | Yellow | Numbers |
| StringLiteral | Yellow | Strings |
| BooleanLiteral | Yellow | true/false |

### Interaction

- **Click node** to expand/collapse children
- **Hover node** to highlight corresponding tokens (future)
- All nodes start expanded for small ASTs, collapsed for large ones

### UI Updates

**Output pane split into tabs:**
```
[Tokens] [AST]
```

Or show both in sequence:
```
Tokens:
  1:1    KEYWORD      let
  ...

AST:
  ▼ Program
    ▼ LetStatement (x)
      ...
```

**Recommendation:** Keep simple - show tokens first, then AST tree below.

## Implementation

### AST Renderer Class

```javascript
// src/ast-renderer.js
class ASTRenderer {
  constructor(container) {
    this.container = container;
  }

  // Render the full AST
  render(ast) {
    this.container.innerHTML = '';
    const tree = this.renderNode(ast, 0);
    this.container.appendChild(tree);
  }

  // Render a single node and its children
  renderNode(node, depth) {
    const div = document.createElement('div');
    div.className = `ast-node ast-${node.type.toLowerCase()}`;
    div.style.marginLeft = `${depth * 20}px`;

    // Node header (type + key info)
    const header = this.renderHeader(node);
    div.appendChild(header);

    // Children
    const children = this.getChildren(node);
    if (children.length > 0) {
      const childContainer = document.createElement('div');
      childContainer.className = 'ast-children';
      for (const child of children) {
        childContainer.appendChild(this.renderNode(child.node, depth + 1));
      }
      div.appendChild(childContainer);
    }

    return div;
  }

  // Get child nodes to render
  getChildren(node) {
    // Return array of { name, node } for each child
  }

  // Render node header
  renderHeader(node) {
    // Return header element with type and summary
  }
}
```

### CSS for AST Tree

```css
/* AST Tree */
.ast-tree {
  font-family: var(--font-mono);
  font-size: 13px;
  line-height: 1.4;
}

.ast-node {
  position: relative;
}

.ast-header {
  display: flex;
  align-items: center;
  padding: 2px 4px;
  border-radius: 3px;
  cursor: pointer;
}

.ast-header:hover {
  background: rgba(255, 255, 255, 0.1);
}

.ast-type {
  font-weight: 500;
  margin-right: 8px;
}

.ast-value {
  color: #888;
}

/* Node type colors */
.ast-program .ast-type { color: #888; }
.ast-letstatement .ast-type { color: #64b5f6; }
.ast-assignstatement .ast-type { color: #64b5f6; }
.ast-printstatement .ast-type { color: #81c784; }
.ast-ifstatement .ast-type { color: #ba68c8; }
.ast-whilestatement .ast-type { color: #ba68c8; }
.ast-block .ast-type { color: #888; }
.ast-binaryexpression .ast-type { color: #ffb74d; }
.ast-identifier .ast-type { color: #4dd0e1; }
.ast-numberliteral .ast-type { color: #fff176; }
.ast-stringliteral .ast-type { color: #fff176; }
.ast-booleanliteral .ast-type { color: #fff176; }

/* Tree lines */
.ast-children {
  border-left: 1px solid #444;
  margin-left: 8px;
  padding-left: 12px;
}

/* Collapse/expand */
.ast-toggle {
  width: 16px;
  text-align: center;
  color: #666;
}

.ast-collapsed .ast-children {
  display: none;
}
```

### Integration with main.js

Update `runAll()` to use ASTRenderer:

```javascript
// In runAll():
// ... after parsing ...

// Render tokens (text)
outputText += 'Tokens:\n';
// ... existing token rendering ...

// Render AST (visual tree)
const astContainer = document.createElement('div');
astContainer.className = 'ast-tree';
const astRenderer = new ASTRenderer(astContainer);
astRenderer.render(parseResult.ast);

// Show both in output
output.innerHTML = '';
const tokensDiv = document.createElement('pre');
tokensDiv.textContent = outputText;
output.appendChild(tokensDiv);
output.appendChild(astContainer);
```

## File Structure

```
src/
  lexer.js           # Existing
  scanner.js         # Existing
  parser.js          # Existing
  ast-renderer.js    # NEW - AST tree visualization
  visualizer.js      # Existing
  main.js            # Updated - integrate AST renderer
  reference.js       # Existing
  examples.js        # Existing
styles/
  main.css           # Updated - AST tree styles
```

## Refactoring in This Release

To address long functions in main.js:

1. Extract token rendering to helper function
2. Move AST rendering to ASTRenderer class
3. Keep `runAll()` focused on orchestration

## Playwright Tests

### Positive Tests

1. **"AST tree is displayed after run"**
   - Input: `let x = 42`
   - Verify `.ast-tree` element exists

2. **"AST shows Program root node"**
   - Input: `let x = 42`
   - Verify "Program" text appears in AST

3. **"AST shows LetStatement node"**
   - Input: `let x = 42`
   - Verify "LetStatement" appears

4. **"AST shows variable name"**
   - Input: `let x = 42`
   - Verify "x" appears in AST

5. **"AST shows NumberLiteral"**
   - Input: `let x = 42`
   - Verify "NumberLiteral" and "42" appear

6. **"AST shows BinaryExpression"**
   - Input: `1 + 2`
   - Verify "BinaryExpression" and "+" appear

7. **"AST shows nested structure"**
   - Input: `if (x > 0) { print x }`
   - Verify IfStatement contains Block contains PrintStatement

8. **"AST shows multiple statements"**
   - Input: `let x = 1\nlet y = 2`
   - Verify two LetStatement nodes

9. **"AST colors node types differently"**
   - Input: `let x = 42`
   - Verify different CSS classes on different node types

10. **"AST nodes can be collapsed"**
    - Input: `let x = 42`
    - Click on LetStatement node
    - Verify children are hidden

11. **"collapsed nodes can be expanded"**
    - Collapse then expand a node
    - Verify children are visible again

12. **"tokens still displayed with AST"**
    - Input: `let x = 42`
    - Verify both "Tokens:" section and AST tree visible

### Negative Tests

13. **"AST shows error node for invalid syntax"**
    - Input: `let x`
    - Verify parser error is shown and partial AST displayed

14. **"empty input shows empty AST"**
    - Input: (empty)
    - Verify greeting or empty program

## Deliverables

- [x] Create src/ast-renderer.js
- [x] Update src/main.js to use ASTRenderer
- [x] Update styles/main.css with AST tree styles
- [x] Update index.html to include ast-renderer.js
- [x] tests/ast.spec.js with 14 tests
- [x] All tests passing (77 total: 7 UI + 13 lexer + 23 lexer-viz + 20 parser + 14 AST)

## Post-Release Changes

### Tabbed Output (TDD)

Added tabs to separate Tokens, AST, and Output views:

**Tests written first (6 new tests in ui.spec.js):**
- output pane has three tabs
- tokens tab is active by default after run
- clicking AST tab shows AST content
- clicking Output tab shows output content
- tokens tab shows token list
- tabs switch content visibility

**Implementation:**
- Added tabs UI in index.html
- Added tab styles in main.css
- Updated main.js with tab switching logic
- Updated runAll() to render to separate tab panels
- Updated existing tests to work with tabs

**Total tests: 83** (7 UI + 6 tabs + 13 lexer + 23 lexer-viz + 20 parser + 14 AST)

## Status

**COMPLETE**
