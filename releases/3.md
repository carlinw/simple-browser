# Release 3: Lexer Visualization

> Follow CLAUDE.md - do not implement until user approves complete release plan.

## Goal

Add step-through visualization to the lexer so Connor can watch tokens being created one at a time. This helps build intuition for how lexers work - scanning source code character by character and recognizing patterns.

## Features

### Step-Through Mode

New toolbar buttons:
- **[Run]** - Tokenize all at once (existing behavior)
- **[Step]** - Tokenize one token at a time
- **[Reset]** - Clear and start over

### Visual Feedback

1. **Source Highlighting** - Highlight the portion of code currently being tokenized
2. **Token List** - Show tokens as they're created, one by one
3. **Current Position** - Show line:column indicator

### UI Layout Update

```
+------------------------------------------+
|              Simple Interpreter          |
+------------------------------------------+
| [Language Syntax] [Example] [Run] [Step] [Reset] |
+------------------------------------------+
|                    |                     |
|   Code Editor      |     Output          |
|   (with highlight) |     (token list)    |
|                    |                     |
+------------------------------------------+
```

### Language Reference Panel

A **[Language Syntax]** button in the toolbar opens a reference panel showing what syntax is available. This grows with each release as we add language features.

```
+------------------------------------------+
|         Language Reference        [Close]|
+------------------------------------------+
| KEYWORDS                                 |
|   let      - declare a variable          |
|   if/else  - conditional                 |
|   while    - loop                        |
|   function - define a function           |
|   return   - return from function        |
|   print    - output to console           |
|   stop     - pause execution (debugger)  |
|   true/false - boolean values            |
|                                          |
| OPERATORS                                |
|   + - * /  - arithmetic                  |
|   =        - assignment                  |
|   == !=    - equality                    |
|   < > <= >= - comparison                 |
|                                          |
| EXAMPLES                                 |
|   let x = 42                             |
|   print x + 1                            |
|   if (x > 0) { print "positive" }        |
+------------------------------------------+
```

The panel can be:
- A modal overlay (click outside or [Close] to dismiss)
- Always accessible via [Language Syntax] button
- Updated each release as new features are added

### Example Program: Tokenizer Demo

A preloaded example program demonstrates the tokenizer. Accessible via:
- **[Example]** button in toolbar, OR
- Dropdown: **[Examples ▾]** → "Tokenizer Demo"

When clicked, loads this code into the editor:

```
// Tokenizer Demo
// Step through to see how the lexer breaks code into tokens

let message = "Hello, Connor!"
let count = 42

// Try different token types:
// - Keywords: let, if, while, print
// - Numbers: 42, 0, 100
// - Strings: "hello"
// - Operators: + - * / = == < >

print message
print count + 1

if (count > 0) {
    print "positive"
}
```

This example showcases:
- Comments (visible during step-through, skipped in run mode)
- Whitespace (visible during step-through, skipped in run mode)
- Keywords (let, if, print)
- Identifiers (message, count)
- Strings ("Hello, Connor!")
- Numbers (42, 0, 1)
- Operators (=, +, >)
- Punctuation (parentheses, braces)

### Behavior

**Run Mode** (existing):
1. Click [Run]
2. All tokens appear at once in output

**Step Mode** (new):
1. Click [Step] to start
2. First token is created, highlighted in source
3. Click [Step] again for next token
4. Repeat until EOF
5. Click [Reset] to start over

### Source Highlighting

When stepping, highlight the characters that form the current token:

```
let x = 42
^^^
```
Shows "let" highlighted, output shows:
```
Tokens:
→ 1:1   KEYWORD     let
```

Next step:
```
let x = 42
    ^
```
Shows "x" highlighted, output shows:
```
Tokens:
  1:1   KEYWORD     let
→ 1:5   IDENTIFIER  x
```

The arrow (→) indicates the most recently added token.

### Implementation Approach

#### Stepping Lexer

Modify the Lexer to support step-by-step tokenization:

```javascript
class Lexer {
  // ... existing code ...

  // New method: get next token without tokenizing everything
  nextToken() {
    this.skipWhitespaceAndComments();
    if (this.isAtEnd()) {
      return this.makeToken(TokenType.EOF, null, '');
    }
    // ... scan one token and return it
  }

  // Track start position of current token for highlighting
  getTokenSpan() {
    return {
      start: this.tokenStart,
      end: this.pos,
      line: this.tokenLine,
      column: this.tokenColumn
    };
  }
}
```

#### Highlighting in Textarea

Textareas don't support inline highlighting. Options:

**Option A: Overlay approach**
- Position a transparent div over the textarea
- Use a `<mark>` element to highlight text
- Sync scroll positions

**Option B: Replace textarea with contenteditable div**
- More control over styling
- More complex to handle input

**Option C: Side-by-side display**
- Keep textarea for editing
- Show highlighted code in a separate read-only display when stepping

**Recommended: Option C** - Simplest, cleanest separation of concerns.

When stepping:
- Disable the textarea (read-only during step mode)
- Show a highlighted code view alongside or replacing the textarea temporarily
- User clicks [Reset] to return to edit mode

### UI States

| State | Toolbar | Editor | Output |
|-------|---------|--------|--------|
| **Edit** | [Run] [Step] enabled, [Reset] disabled | Editable textarea | Empty or previous output |
| **Stepping** | [Run] disabled, [Step] [Reset] enabled | Read-only with highlight | Growing token list |
| **Done** | [Run] [Step] disabled, [Reset] enabled | Read-only, full highlight | Complete token list |

### Code Display Component

New component for showing highlighted source:

```html
<div id="code-display" class="code-display hidden">
  <span class="code-before">let </span>
  <span class="code-current">x</span>
  <span class="code-after"> = 42</span>
</div>
```

```css
.code-display {
  font-family: var(--font-mono);
  white-space: pre-wrap;
  padding: 0.75rem;
  background: white;
  border: 1px solid var(--color-border);
  border-radius: 4px;
}

.code-current {
  background: #ffeb3b;  /* Yellow highlight */
  border-radius: 2px;
}

.code-before,
.code-after {
  opacity: 0.7;
}
```

### File Structure

```
src/
  lexer.js             # Updated - add nextToken(), getTokenSpan()
  scanner.js           # NEW - character-by-character scanning with state machine
  main.js              # Updated - stepping logic, UI state management
  visualizer.js        # NEW - code highlighting component (token + character level)
  reference.js         # NEW - language reference panel
  examples.js          # NEW - example programs
styles/
  main.css             # Updated - styles for highlighting, modal, scanner state display
```

## Class Design

### Visualizer (src/visualizer.js)

```javascript
class CodeVisualizer {
  constructor(containerElement) {
    this.container = containerElement;
  }

  // Show source with highlight at given span
  highlight(source, span) {
    const before = source.substring(0, span.start);
    const current = source.substring(span.start, span.end);
    const after = source.substring(span.end);
    // Render with highlighting
  }

  // Clear highlighting
  clear() { }

  // Show/hide the visualizer
  show() { }
  hide() { }
}
```

### Reference Panel (src/reference.js)

```javascript
class ReferencePanel {
  constructor() {
    this.isOpen = false;
  }

  // Show the reference modal
  open() {
    this.isOpen = true;
    this.render();
  }

  // Hide the reference modal
  close() {
    this.isOpen = false;
    this.hide();
  }

  // Toggle open/close
  toggle() {
    this.isOpen ? this.close() : this.open();
  }

  // Get current language reference content
  // This will be updated as we add language features
  getContent() {
    return {
      keywords: [
        { name: 'let', desc: 'declare a variable' },
        { name: 'if', desc: 'conditional' },
        { name: 'else', desc: 'conditional branch' },
        { name: 'while', desc: 'loop' },
        { name: 'function', desc: 'define a function' },
        { name: 'return', desc: 'return from function' },
        { name: 'print', desc: 'output to console' },
        { name: 'stop', desc: 'pause execution (debugger)' },
        { name: 'true', desc: 'boolean true' },
        { name: 'false', desc: 'boolean false' },
      ],
      operators: [
        { name: '+ - * /', desc: 'arithmetic' },
        { name: '=', desc: 'assignment' },
        { name: '== !=', desc: 'equality' },
        { name: '< > <= >=', desc: 'comparison' },
      ],
      examples: [
        'let x = 42',
        'print x + 1',
        'if (x > 0) { print "positive" }',
      ]
    };
  }

  render() { /* Build and show modal HTML */ }
  hide() { /* Remove modal from DOM */ }
}
```

### Updated Main.js

```javascript
// UI State
let state = 'edit';  // 'edit' | 'stepping' | 'done'
let lexer = null;
let tokens = [];
let currentSpan = null;

// Button handlers
runBtn.onclick = runAll;
stepBtn.onclick = stepOne;
resetBtn.onclick = reset;

function runAll() {
  // Existing behavior - tokenize everything at once
}

function stepOne() {
  if (state === 'edit') {
    // Initialize stepping
    state = 'stepping';
    lexer = new Lexer(codeEditor.value);
    tokens = [];
    updateUI();
  }

  // Get next token
  const token = lexer.nextToken();
  const span = lexer.getTokenSpan();
  tokens.push(token);

  // Update visualization
  visualizer.highlight(codeEditor.value, span);
  renderTokens(tokens);

  if (token.type === 'EOF') {
    state = 'done';
    updateUI();
  }
}

function reset() {
  state = 'edit';
  lexer = null;
  tokens = [];
  visualizer.hide();
  updateUI();
}

function updateUI() {
  // Enable/disable buttons based on state
  // Show/hide code display vs textarea
}
```

## Playwright Tests

### Positive Tests

1. **"step button exists"**
   - Verify [Step] button is visible

2. **"reset button exists"**
   - Verify [Reset] button is visible

3. **"stepping creates one token at a time"**
   - Enter `let x`
   - Click [Step] - shows KEYWORD (let)
   - Click [Step] - shows WHITESPACE
   - Click [Step] - shows IDENTIFIER (x)

4. **"stepping highlights current token in source"**
   - Enter `let x`
   - Click [Step]
   - Verify "let" is highlighted (has highlight class)

5. **"stepping disables run button"**
   - Enter `let x`
   - Click [Step]
   - Verify [Run] button is disabled

6. **"reset clears tokens and returns to edit mode"**
   - Enter `let x`
   - Click [Step]
   - Click [Reset]
   - Verify output is cleared
   - Verify textarea is editable

7. **"stepping through all tokens reaches EOF"**
   - Enter `42`
   - Click [Step] (NUMBER)
   - Click [Step] (EOF)
   - Verify [Step] is disabled after EOF

8. **"run still works for full tokenization"**
   - Enter `let x = 42`
   - Click [Run]
   - Verify all tokens appear at once

9. **"highlight moves with each step"**
   - Enter `a b`
   - Step through tokens (a, whitespace, b)
   - Verify highlight position changes each time, including whitespace

10. **"arrow indicates current token"**
    - Enter `let x`
    - Click [Step]
    - Verify arrow (→) appears next to current token in output

### Language Syntax Panel Tests

11. **"language syntax button exists in toolbar"**
    - Verify [Language Syntax] button is visible in toolbar

12. **"clicking help opens reference panel"**
    - Click [Language Syntax]
    - Verify reference panel/modal is visible
    - Verify it shows "Language Reference" heading

13. **"reference panel shows keywords"**
    - Open reference panel
    - Verify it contains keywords: let, if, while, print, etc.

14. **"reference panel shows operators"**
    - Open reference panel
    - Verify it contains operators: +, -, *, /, =, ==, etc.

15. **"reference panel shows examples"**
    - Open reference panel
    - Verify it contains example code

16. **"close button closes reference panel"**
    - Open reference panel
    - Click [Close]
    - Verify panel is hidden

### Example Program Tests

17. **"example button exists"**
    - Verify [Example] button/dropdown is visible in toolbar

18. **"clicking example loads tokenizer demo"**
    - Click [Example] or select "Tokenizer Demo"
    - Verify editor contains example code
    - Verify it contains "let message" and "Hello, Connor!"

19. **"can step through example program"**
    - Load example program
    - Click [Step] multiple times
    - Verify tokens are created (KEYWORD, IDENTIFIER, STRING, etc.)

### Negative Tests

20. **"cannot edit while stepping"**
    - Enter `let x`
    - Click [Step]
    - Verify textarea is disabled/readonly

## Deliverables

- [x] Update src/lexer.js with nextToken() and getTokenSpan()
- [x] Create src/visualizer.js for code highlighting
- [x] Create src/reference.js for language reference panel
- [x] Create src/examples.js for example programs
- [x] Update src/main.js with stepping logic, help, and examples
- [x] Update index.html with new buttons, code display div, and modal
- [x] Update styles/main.css with highlighting and modal styles
- [x] tests/lexer-viz.spec.js with 20 tests
- [x] All tests passing (40 total: 7 UI + 13 lexer + 20 lexer-viz)

## Status

**COMPLETE**

## Post-Release Changes (User Testing)

The following changes were made after initial release based on user testing feedback:

### 1. Whitespace and Comment Token Visualization

**Issue:** Stepping through code skipped whitespace and comments invisibly, hiding how lexers actually scan character by character.

**Fix:** Added WHITESPACE and COMMENT token types that are shown during step-through mode:
- Step mode shows all tokens including whitespace and comments (dimmed/italic styling)
- Run mode filters these out for clean output
- Connor can now see the lexer processing every character, not just significant tokens

```javascript
// New token types in lexer.js
const TokenType = {
  // ... existing types ...
  COMMENT: 'COMMENT',       // For visualization - shows comment being scanned
  WHITESPACE: 'WHITESPACE', // For visualization - shows whitespace being scanned
};
```

### 2. Toolbar Button Reordering

**Change:** Buttons reordered from left to right:
- **Before:** Run, Step, Reset, Help (left) | Example (right)
- **After:** Language Syntax, Example, Run, Step, Reset (all left-aligned)

This groups reference/learning tools (Language Syntax, Example) together, followed by execution controls (Run, Step, Reset).

### 3. Help Button Renamed

**Change:** "Help" button renamed to "Language Syntax" for clarity about what the panel contains.

### 4. Character-by-Character Stepping

**Issue:** Token-by-token stepping still hid the actual character scanning process. Connor couldn't see how the lexer reads one character at a time and decides when to emit tokens.

**Fix:** Completely redesigned stepping to work character-by-character:

**New Scanner class** (`src/scanner.js`):
- State machine tracking what type of token is being built (IDLE, IDENTIFIER, NUMBER, STRING, OPERATOR, WHITESPACE, COMMENT)
- Each step reads one character and shows the decision made
- Buffer accumulates characters until a token boundary is detected
- Clear action descriptions explain what the lexer is "thinking"

**Updated visualization**:
- **Code display**: Shows already-processed code (gray), buffer being built (blue), current character cursor (yellow), and pending code (gray)
- **Scanner State panel**: Shows current position, character being read, what token type is being built, buffer contents, and action taken
- **Token list**: Shows completed tokens with arrow (→) indicating newly emitted ones

**Example step-through of "let x"**:
```
Step 1: Initialize
Step 2: Read 'l' - Start building IDENTIFIER
Step 3: Read 'e' - Add to buffer "le"
Step 4: Read 't' - Add to buffer "let"
Step 5: Read ' ' - Token boundary! Emit KEYWORD "let"
Step 6: Read ' ' - Start building WHITESPACE
Step 7: Read 'x' - Emit WHITESPACE, start IDENTIFIER
Step 8: Read EOF - Emit IDENTIFIER "x"
Step 9: Emit EOF token
```

This provides much deeper insight into how lexical analysis actually works.

### 5. Bug Fix: Empty Code Display on First Step (TDD)

**Issue discovered:** Manual testing revealed that clicking Example then Step resulted in an empty code display pane. The source code disappeared instead of showing in the visualization area.

**Root cause:** When stepping was initialized, `visualizer.setSource()` was called but the code was never rendered to the display. The `updateUI()` function hid the textarea and showed the code-display div, but nothing was rendered into it.

**TDD Process:**

1. **Wrote failing test first:**
```javascript
test('first step shows source code in display', async ({ page }) => {
  await page.goto('/');
  await page.fill('#code-editor', 'let x');
  await page.click('#step-btn');

  const codeDisplay = page.locator('#code-display');
  await expect(codeDisplay).toBeVisible();

  // Code display should contain the source code (not be empty)
  const displayText = await codeDisplay.textContent();
  expect(displayText).toContain('let x');
});
```

2. **Verified test would have failed** (code display was empty before fix)

3. **Implemented fix:**
   - Added `visualizer.showInitial()` method to display source as "pending" (gray)
   - Called it during step initialization in `main.js`

4. **Verified test passes** - 41 tests now pass

**Lesson learned:** Added TDD requirements to CLAUDE.md - always write a failing test first when fixing bugs.
