# Release 25: String Methods & Virtual DOM Elements

## Goal
Extend TLP with string manipulation methods and a virtual DOM element system for building user interfaces.

## Part 1: String Methods

### New String Methods

| Method | Description | Example | Result |
|--------|-------------|---------|--------|
| `str.substring(start, end)` | Extract portion | `"hello".substring(1, 4)` | `"ell"` |
| `str.indexOf(search)` | Find position (-1 if not found) | `"hello".indexOf("l")` | `2` |
| `str.split(delim)` | Split into array | `"a,b,c".split(",")` | `["a","b","c"]` |
| `str.trim()` | Remove whitespace | `"  hi  ".trim()` | `"hi"` |
| `str.replace(old, new)` | Replace first occurrence | `"hello".replace("l", "L")` | `"heLlo"` |
| `str.startsWith(prefix)` | Check prefix | `"hello".startsWith("he")` | `true` |
| `str.endsWith(suffix)` | Check suffix | `"hello".endsWith("lo")` | `true` |
| `str.toUpper()` | Uppercase | `"Hello".toUpper()` | `"HELLO"` |
| `str.toLower()` | Lowercase | `"Hello".toLower()` | `"hello"` |
| `str.includes(search)` | Contains check | `"hello".includes("ell")` | `true` |

### Implementation

**File:** `src/interpreter.js` - Extend MethodCall handling

```javascript
case 'MethodCall': {
  const object = await this.evaluate(node.object);

  // Handle built-in methods on strings
  if (typeof object === 'string') {
    result = this.evaluateStringMethod(object, node.method, node.arguments);
    break;
  }

  // Handle built-in methods on arrays
  if (Array.isArray(object)) {
    result = this.evaluateArrayMethod(object, node.method, node.arguments);
    break;
  }
  // ... existing instance method handling
}

evaluateStringMethod(str, method, argNodes) {
  const args = [];
  for (const arg of argNodes) {
    args.push(await this.evaluate(arg));
  }

  switch (method) {
    case 'length':
      if (args.length !== 0) throw new RuntimeError('length() takes no arguments');
      return str.length;

    case 'substring':
      if (args.length !== 2) throw new RuntimeError('substring() requires 2 arguments');
      const [start, end] = args;
      if (typeof start !== 'number' || typeof end !== 'number') {
        throw new RuntimeError('substring() requires number arguments');
      }
      return str.substring(start, end);

    case 'indexOf':
      if (args.length !== 1) throw new RuntimeError('indexOf() requires 1 argument');
      if (typeof args[0] !== 'string') {
        throw new RuntimeError('indexOf() requires a string argument');
      }
      return str.indexOf(args[0]);

    case 'split':
      if (args.length !== 1) throw new RuntimeError('split() requires 1 argument');
      if (typeof args[0] !== 'string') {
        throw new RuntimeError('split() requires a string argument');
      }
      return str.split(args[0]);

    case 'trim':
      if (args.length !== 0) throw new RuntimeError('trim() takes no arguments');
      return str.trim();

    case 'replace':
      if (args.length !== 2) throw new RuntimeError('replace() requires 2 arguments');
      if (typeof args[0] !== 'string' || typeof args[1] !== 'string') {
        throw new RuntimeError('replace() requires string arguments');
      }
      return str.replace(args[0], args[1]);

    case 'startsWith':
      if (args.length !== 1) throw new RuntimeError('startsWith() requires 1 argument');
      if (typeof args[0] !== 'string') {
        throw new RuntimeError('startsWith() requires a string argument');
      }
      return str.startsWith(args[0]);

    case 'endsWith':
      if (args.length !== 1) throw new RuntimeError('endsWith() requires 1 argument');
      if (typeof args[0] !== 'string') {
        throw new RuntimeError('endsWith() requires a string argument');
      }
      return str.endsWith(args[0]);

    case 'toUpper':
      if (args.length !== 0) throw new RuntimeError('toUpper() takes no arguments');
      return str.toUpperCase();

    case 'toLower':
      if (args.length !== 0) throw new RuntimeError('toLower() takes no arguments');
      return str.toLowerCase();

    case 'includes':
      if (args.length !== 1) throw new RuntimeError('includes() requires 1 argument');
      if (typeof args[0] !== 'string') {
        throw new RuntimeError('includes() requires a string argument');
      }
      return str.includes(args[0]);

    default:
      throw new RuntimeError(`Unknown string method: ${method}`);
  }
}
```

### String Method Tests

**File:** `tests/string-methods.spec.js`

```javascript
const { test, expect } = require('@playwright/test');
const { runFast } = require('./helpers');

test('substring extracts portion of string', async ({ page }) => {
  await runFast(page, 'print("hello".substring(1, 4))');
  await expect(page.locator('#output')).toHaveText('ell');
});

test('indexOf finds position', async ({ page }) => {
  await runFast(page, 'print("hello".indexOf("l"))');
  await expect(page.locator('#output')).toHaveText('2');
});

test('indexOf returns -1 when not found', async ({ page }) => {
  await runFast(page, 'print("hello".indexOf("x"))');
  await expect(page.locator('#output')).toHaveText('-1');
});

test('split creates array', async ({ page }) => {
  await runFast(page, `
    let parts = "a,b,c".split(",")
    print(parts[1])
  `);
  await expect(page.locator('#output')).toHaveText('b');
});

test('trim removes whitespace', async ({ page }) => {
  await runFast(page, 'print("  hi  ".trim())');
  await expect(page.locator('#output')).toHaveText('hi');
});

test('replace substitutes text', async ({ page }) => {
  await runFast(page, 'print("hello".replace("l", "L"))');
  await expect(page.locator('#output')).toHaveText('heLlo');
});

test('startsWith checks prefix', async ({ page }) => {
  await runFast(page, 'print("hello".startsWith("he"))');
  await expect(page.locator('#output')).toHaveText('true');
});

test('endsWith checks suffix', async ({ page }) => {
  await runFast(page, 'print("hello".endsWith("lo"))');
  await expect(page.locator('#output')).toHaveText('true');
});

test('toUpper converts to uppercase', async ({ page }) => {
  await runFast(page, 'print("Hello".toUpper())');
  await expect(page.locator('#output')).toHaveText('HELLO');
});

test('toLower converts to lowercase', async ({ page }) => {
  await runFast(page, 'print("Hello".toLower())');
  await expect(page.locator('#output')).toHaveText('hello');
});

test('includes checks for substring', async ({ page }) => {
  await runFast(page, 'print("hello".includes("ell"))');
  await expect(page.locator('#output')).toHaveText('true');
});
```

---

## Part 2: Virtual DOM Elements

### Concept

A simple element system that TLP can use to build UIs. Elements are rendered to the canvas but managed as a tree structure.

### New Built-in Functions

| Function | Description | Example |
|----------|-------------|---------|
| `element(type, text)` | Create element | `let btn = element("button", "Click")` |
| `append(parent, child)` | Add child to parent | `append(container, btn)` |
| `remove(element)` | Remove from parent | `remove(btn)` |
| `setAttr(el, name, value)` | Set attribute | `setAttr(btn, "x", 100)` |
| `getAttr(el, name)` | Get attribute | `getAttr(btn, "x")` |
| `on(el, event, handler)` | Add event handler | `on(btn, "click", onClick)` |
| `render()` | Draw all elements | `render()` |
| `root()` | Get root container | `let r = root()` |

### Element Types

| Type | Appearance | Attributes |
|------|------------|------------|
| `"button"` | Rounded rect with text | x, y, width, height, color, textColor |
| `"label"` | Text only | x, y, color, fontSize |
| `"box"` | Rectangle container | x, y, width, height, color |
| `"input"` | Text input field | x, y, width, value, placeholder |
| `"image"` | (future) | x, y, width, height, src |

### Default Attributes

All elements have these default attributes:
- `x`, `y` - position (default: 0, 0)
- `width`, `height` - size (default: auto-calculated)
- `visible` - show/hide (default: true)
- `color` - background/text color (default: varies by type)

### Implementation

**File:** `src/runtime.js` - Add TinyElement class

```javascript
// Element value - represents a virtual DOM element
export class TinyElement {
  constructor(type, text = '') {
    this.type = type;
    this.text = text;
    this.attrs = new Map([
      ['x', 0],
      ['y', 0],
      ['width', null],  // auto
      ['height', null], // auto
      ['visible', true],
      ['color', this.defaultColor(type)],
    ]);
    this.children = [];
    this.parent = null;
    this.handlers = new Map(); // event -> function
  }

  defaultColor(type) {
    switch (type) {
      case 'button': return 'gray';
      case 'label': return 'white';
      case 'box': return 'darkgray';
      case 'input': return 'white';
      default: return 'white';
    }
  }

  setAttribute(name, value) {
    this.attrs.set(name, value);
  }

  getAttribute(name) {
    return this.attrs.get(name);
  }

  appendChild(child) {
    if (child.parent) {
      child.parent.removeChild(child);
    }
    child.parent = this;
    this.children.push(child);
  }

  removeChild(child) {
    const idx = this.children.indexOf(child);
    if (idx !== -1) {
      this.children.splice(idx, 1);
      child.parent = null;
    }
  }

  addHandler(event, fn) {
    this.handlers.set(event, fn);
  }

  // Get bounding box for hit testing
  getBounds() {
    const x = this.attrs.get('x');
    const y = this.attrs.get('y');
    let w = this.attrs.get('width');
    let h = this.attrs.get('height');

    // Auto-size based on type
    if (w === null) {
      w = this.type === 'button' ? 80 : this.type === 'input' ? 150 : 100;
    }
    if (h === null) {
      h = this.type === 'button' ? 30 : this.type === 'input' ? 25 : 20;
    }

    return { x, y, width: w, height: h };
  }
}
```

**File:** `src/interpreter.js` - Add element built-ins

```javascript
import { TinyElement } from './runtime.js';

// In constructor:
this.rootElement = new TinyElement('box', '');
this.rootElement.setAttribute('width', CANVAS_WIDTH);
this.rootElement.setAttribute('height', CANVAS_HEIGHT);
this.rootElement.setAttribute('color', 'black');

// In tryBuiltinCall:
case 'element': {
  if (args.length < 1 || args.length > 2) {
    throw new RuntimeError('element() requires 1-2 arguments (type, text?)');
  }
  const type = args[0];
  const text = args[1] || '';
  if (typeof type !== 'string') {
    throw new RuntimeError('element() type must be a string');
  }
  return new TinyElement(type, String(text));
}

case 'append': {
  if (args.length !== 2) {
    throw new RuntimeError('append() requires 2 arguments (parent, child)');
  }
  const [parent, child] = args;
  if (!(parent instanceof TinyElement) || !(child instanceof TinyElement)) {
    throw new RuntimeError('append() requires element arguments');
  }
  parent.appendChild(child);
  return null;
}

case 'remove': {
  if (args.length !== 1) {
    throw new RuntimeError('remove() requires 1 argument');
  }
  const el = args[0];
  if (!(el instanceof TinyElement)) {
    throw new RuntimeError('remove() requires an element');
  }
  if (el.parent) {
    el.parent.removeChild(el);
  }
  return null;
}

case 'setAttr': {
  if (args.length !== 3) {
    throw new RuntimeError('setAttr() requires 3 arguments (element, name, value)');
  }
  const [el, name, value] = args;
  if (!(el instanceof TinyElement)) {
    throw new RuntimeError('setAttr() requires an element');
  }
  if (typeof name !== 'string') {
    throw new RuntimeError('setAttr() name must be a string');
  }
  el.setAttribute(name, value);
  return null;
}

case 'getAttr': {
  if (args.length !== 2) {
    throw new RuntimeError('getAttr() requires 2 arguments (element, name)');
  }
  const [el, name] = args;
  if (!(el instanceof TinyElement)) {
    throw new RuntimeError('getAttr() requires an element');
  }
  if (typeof name !== 'string') {
    throw new RuntimeError('getAttr() name must be a string');
  }
  return el.getAttribute(name);
}

case 'on': {
  if (args.length !== 3) {
    throw new RuntimeError('on() requires 3 arguments (element, event, handler)');
  }
  const [el, event, handler] = args;
  if (!(el instanceof TinyElement)) {
    throw new RuntimeError('on() requires an element');
  }
  if (typeof event !== 'string') {
    throw new RuntimeError('on() event must be a string');
  }
  if (!(handler instanceof TinyFunction)) {
    throw new RuntimeError('on() handler must be a function');
  }
  el.addHandler(event, handler);
  return null;
}

case 'render': {
  if (args.length !== 0) {
    throw new RuntimeError('render() takes no arguments');
  }
  this.renderElements(this.rootElement);
  return null;
}

case 'root': {
  if (args.length !== 0) {
    throw new RuntimeError('root() takes no arguments');
  }
  return this.rootElement;
}

// Add rendering method
renderElements(el) {
  if (!el.getAttribute('visible')) return;

  const bounds = el.getBounds();
  const color = el.getAttribute('color');

  switch (el.type) {
    case 'box':
      this.onColor(COLORS[color] || color);
      this.onRect(bounds.x, bounds.y, bounds.width, bounds.height);
      break;

    case 'button':
      // Background
      this.onColor(COLORS[color] || color);
      this.onRect(bounds.x, bounds.y, bounds.width, bounds.height);
      // Text
      const textColor = el.getAttribute('textColor') || 'white';
      this.onColor(COLORS[textColor] || textColor);
      this.onText(bounds.x + 10, bounds.y + 20, el.text);
      break;

    case 'label':
      this.onColor(COLORS[color] || color);
      this.onText(bounds.x, bounds.y, el.text);
      break;

    case 'input':
      // Background
      this.onColor(COLORS[color] || color);
      this.onRect(bounds.x, bounds.y, bounds.width, bounds.height);
      // Text/value
      this.onColor(COLORS['black']);
      const val = el.getAttribute('value') || el.getAttribute('placeholder') || '';
      this.onText(bounds.x + 5, bounds.y + 17, val);
      break;
  }

  // Render children
  for (const child of el.children) {
    this.renderElements(child);
  }
}
```

### Click Handling

**File:** `src/output-renderer.js` - Add click detection

```javascript
// In canvas setup:
this.canvas.addEventListener('click', (e) => {
  const rect = this.canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  this.onCanvasClick?.(x, y);
});

// Expose setter
setClickHandler(handler) {
  this.onCanvasClick = handler;
}
```

**File:** `src/interpreter.js` - Wire up click handling

```javascript
// In constructor, wire up click handler
if (options.setClickHandler) {
  options.setClickHandler((x, y) => this.handleClick(x, y));
}

// Hit test and dispatch click
async handleClick(x, y) {
  const hit = this.hitTest(this.rootElement, x, y);
  if (hit && hit.handlers.has('click')) {
    const handler = hit.handlers.get('click');
    await this.callFunction(handler, []);
  }
}

hitTest(el, x, y) {
  // Check children first (front to back)
  for (let i = el.children.length - 1; i >= 0; i--) {
    const hit = this.hitTest(el.children[i], x, y);
    if (hit) return hit;
  }

  // Check this element
  const bounds = el.getBounds();
  if (x >= bounds.x && x < bounds.x + bounds.width &&
      y >= bounds.y && y < bounds.y + bounds.height) {
    return el;
  }

  return null;
}
```

### Example Program

```
// Simple counter UI

let count = 0

function updateDisplay() {
  setAttr(countLabel, "text", "Count: " + count)
  render()
}

function increment() {
  count = count + 1
  updateDisplay()
}

function decrement() {
  count = count - 1
  updateDisplay()
}

// Create UI
let container = root()

let countLabel = element("label", "Count: 0")
setAttr(countLabel, "x", 150)
setAttr(countLabel, "y", 100)
append(container, countLabel)

let plusBtn = element("button", "+")
setAttr(plusBtn, "x", 100)
setAttr(plusBtn, "y", 150)
setAttr(plusBtn, "width", 50)
on(plusBtn, "click", increment)
append(container, plusBtn)

let minusBtn = element("button", "-")
setAttr(minusBtn, "x", 200)
setAttr(minusBtn, "y", 150)
setAttr(minusBtn, "width", 50)
on(minusBtn, "click", decrement)
append(container, minusBtn)

render()
print("Click + or - to change count")
```

---

## Tests

### Virtual DOM Tests

**File:** `tests/virtual-dom.spec.js`

```javascript
const { test, expect } = require('@playwright/test');
const { runFast } = require('./helpers');

test('element creates element object', async ({ page }) => {
  await runFast(page, `
    let btn = element("button", "Click")
    print("created")
  `);
  await expect(page.locator('#output')).toHaveText('created');
});

test('append adds child to parent', async ({ page }) => {
  await runFast(page, `
    let parent = element("box", "")
    let child = element("label", "Hello")
    append(parent, child)
    print("appended")
  `);
  await expect(page.locator('#output')).toHaveText('appended');
});

test('setAttr and getAttr work', async ({ page }) => {
  await runFast(page, `
    let btn = element("button", "Test")
    setAttr(btn, "x", 50)
    print(getAttr(btn, "x"))
  `);
  await expect(page.locator('#output')).toHaveText('50');
});

test('render draws elements to canvas', async ({ page }) => {
  await runFast(page, `
    let r = root()
    let btn = element("button", "Hello")
    setAttr(btn, "x", 10)
    setAttr(btn, "y", 10)
    append(r, btn)
    render()
  `);
  const canvas = page.locator('canvas');
  await expect(canvas).toBeVisible();
});

test('root returns root element', async ({ page }) => {
  await runFast(page, `
    let r = root()
    print(getAttr(r, "width"))
  `);
  await expect(page.locator('#output')).toHaveText('400');
});
```

---

## File Changes Summary

| File | Changes |
|------|---------|
| src/constants.js | Add default element sizes |
| src/runtime.js | Add TinyElement class |
| src/interpreter.js | Add string methods, element builtins, render, click handling |
| src/output-renderer.js | Add click event forwarding |
| src/main.js | Wire click handler to interpreter |
| language-help.html | Document string methods and elements |
| tests/string-methods.spec.js | New test file |
| tests/virtual-dom.spec.js | New test file |

## Implementation Order

### Phase 1: String Methods
1. [ ] Add evaluateStringMethod() to interpreter
2. [ ] Add string method tests
3. [ ] Update language-help.html

### Phase 2: Virtual DOM
1. [ ] Add TinyElement class to runtime.js
2. [ ] Add element(), append(), remove(), setAttr(), getAttr() builtins
3. [ ] Add render() builtin with element drawing
4. [ ] Add root() builtin
5. [ ] Add on() builtin for event handlers
6. [ ] Add click handling (output-renderer + interpreter)
7. [ ] Add virtual DOM tests
8. [ ] Update language-help.html
9. [ ] Create example program

## Future Enhancements

- Keyboard focus for input elements
- Layout containers (vbox, hbox)
- More event types (hover, keypress)
- Animation support
- CSS-like styling
