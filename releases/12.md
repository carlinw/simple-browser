# Release 12: Call Stack Visualization + Refactoring

> Follow CLAUDE.md - do not implement until user approves complete release plan.

## Code Quality Analysis

### Before Release 12

**Codebase:** ~6,000 lines across 30 files (15 src, 14 tests, 3 css, 1 html)
**Tests:** 177 passing

| File | Lines | Issue |
|------|-------|-------|
| interpreter.css | 524 | MONITOR - approaching 600 |
| interpreter.js | 330 | Multiple concerns - split recommended |
| main.js | 341 | runAnimated/runFast duplication |

### After Release 12

**Codebase:** ~6,300 lines across 32 files (16 src, 15 tests, 3 css, 1 html)
**Tests:** 184 passing

| File | Lines | Change |
|------|-------|--------|
| interpreter.css | 614 | +90 (stack frame CSS) - MONITOR |
| parser.js | 459 | — |
| lexer.js | 390 | — |
| scanner.js | 384 | — |
| main.js | 336 | -5 (DRY refactor) |
| ast-renderer.js | 314 | — |
| interpreter.js | 266 | -64 (extracted to runtime.js) |
| examples.js | 209 | — |
| memory-renderer.js | 187 | +94 (call stack display) |
| runtime.js | 77 | NEW (extracted classes) |

### DRY Issues Addressed

**1. runAnimated/runFast duplication in main.js** ✓ FIXED

Extracted `executeCode({ animated })` helper that consolidates:
- Source retrieval and parsing
- Output tracking
- Interpreter creation with callbacks
- Error handling
- State management

**2. interpreter.js multiple concerns** ✓ FIXED

Extracted to `src/runtime.js`:
- Environment class (scope management)
- SimpleFunction class (function values)
- ReturnValue class (return exception)
- RuntimeError class

interpreter.js now contains only the Interpreter class (AST walker).

---

## Goals

### 1. Call Stack Visualization (from roadmap)

Show the call stack during function execution. When a function is called, a new stack frame appears. When it returns, the frame is removed.

This teaches Connor how function calls work - each call creates a new "frame" with its own local variables.

### 2. Refactor for DRY

Extract shared execution logic and split interpreter.js for better organization.

---

## Feature: Call Stack Visualization

### Visual Design

```
┌─────────────────────────────────────────────────────────┐
│  Memory                                                  │
├─────────────────────────────────────────────────────────┤
│  Call Stack:                                             │
│  ┌─────────────────────────────────────────────────────┐│
│  │ factorial(n=3)                                      ││
│  │   n: 3                                              ││
│  ├─────────────────────────────────────────────────────┤│
│  │ factorial(n=2)                                      ││
│  │   n: 2                                              ││
│  ├─────────────────────────────────────────────────────┤│
│  │ factorial(n=1)                                      ││
│  │   n: 1                                              ││
│  ├─────────────────────────────────────────────────────┤│
│  │ <global>                                            ││
│  │   factorial: [function]                             ││
│  └─────────────────────────────────────────────────────┘│
│                                                          │
│  Legend: [stack frame colors]                            │
└─────────────────────────────────────────────────────────┘
```

### Implementation

#### New Interpreter Callbacks

```javascript
const interpreter = new Interpreter({
  // ... existing callbacks ...
  onCallStart: (funcName, args, environment) => {
    // Called when entering a function
    memoryRenderer.pushFrame(funcName, args, environment);
  },
  onCallEnd: (funcName, returnValue) => {
    // Called when exiting a function
    memoryRenderer.popFrame();
  }
});
```

#### Interpreter Changes

In the CallExpression evaluation, emit events:

```javascript
case 'CallExpression': {
  // ... argument evaluation ...

  // Notify call start
  this.onCallStart(node.callee, args, funcEnv);

  try {
    await this.execute(callee.declaration.body);
    result = null;
  } catch (e) {
    if (e instanceof ReturnValue) {
      result = e.value;
    } else {
      throw e;
    }
  } finally {
    this.environment = previousEnv;
    // Notify call end
    this.onCallEnd(node.callee, result);
  }
  break;
}
```

#### MemoryRenderer Changes

Replace simple variable display with stack-based display:

```javascript
class MemoryRenderer {
  constructor(container) {
    this.container = container;
    this.callStack = [];  // Stack of { name, environment } frames
  }

  // Push a new stack frame
  pushFrame(funcName, args, environment) {
    this.callStack.push({ name: funcName, args, environment });
    this.render();
  }

  // Pop the top stack frame
  popFrame() {
    this.callStack.pop();
    this.render();
  }

  // Set the global frame (called at start of execution)
  setGlobalFrame(environment) {
    this.callStack = [{ name: '<global>', args: [], environment }];
    this.render();
  }

  render() {
    // Render stack frames from top to bottom
    // Each frame shows function name and local variables
  }
}
```

---

## Refactoring: Extract runtime.js

### New File: src/runtime.js

```javascript
// Simple Interpreter - Runtime Classes

class Environment {
  constructor(parent = null) {
    this.values = new Map();
    this.parent = parent;
  }
  // ... existing methods ...
}

class SimpleFunction {
  constructor(declaration, closure) {
    this.declaration = declaration;
    this.closure = closure;
  }
}

class ReturnValue {
  constructor(value) {
    this.value = value;
  }
}

class RuntimeError extends Error {
  constructor(message) {
    super(message);
    this.name = 'RuntimeError';
  }
}

// Export
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { Environment, SimpleFunction, ReturnValue, RuntimeError };
}
```

### Updated interpreter.js

Remove the extracted classes, import from runtime.js (or just rely on global scope in browser).

---

## Refactoring: Extract executeCode helper in main.js

### Before (duplicated)

```javascript
async function runAnimated() { /* ~50 lines */ }
async function runFast() { /* ~30 lines */ }
```

### After (DRY)

```javascript
// Shared execution logic
async function executeCode(options = {}) {
  const { animated = false } = options;
  const source = codeEditor.value;
  const success = parseOnly();
  if (!success || !currentParseResult) return;

  const printedOutput = [];

  if (animated) {
    state = 'running';
    updateUI();
    switchTab('ast');
    visualizer.setSource(source);
    visualizer.showInitial();
    codeEditor.classList.add('hidden');
    codeDisplay.classList.remove('hidden');
    outputRenderer.clear();
  }

  const interpreter = new Interpreter({
    stepDelay: animated ? 5000 : 0,
    onNodeEnter: animated ? (node) => {
      astRenderer.highlightNode(node);
      const span = getNodeSpan(node);
      if (span) visualizer.highlightExecuting(span);
    } : undefined,
    onVariableChange: (name, value, action) => {
      memoryRenderer.render(interpreter.environment);
      if (animated) memoryRenderer.highlightVariable(name);
    },
    onPrint: (value) => {
      printedOutput.push(value);
      if (animated) outputRenderer.renderOutput(printedOutput);
    },
    onCallStart: (name, args, env) => memoryRenderer.pushFrame(name, args, env),
    onCallEnd: () => memoryRenderer.popFrame()
  });

  // Set global frame
  memoryRenderer.setGlobalFrame(interpreter.environment);

  try {
    await interpreter.interpret(currentParseResult.ast);
    if (animated) {
      astRenderer.clearHighlights();
      visualizer.clearExecutingHighlight();
    } else {
      outputRenderer.renderOutput(printedOutput);
      visualizer.setSource(source);
      visualizer.showInitial();
    }
  } catch (error) {
    if (animated) {
      astRenderer.clearHighlights();
      visualizer.clearExecutingHighlight();
    }
    outputRenderer.renderErrors([], [], [{ message: error.message }]);
  }

  state = 'done';
  updateUI();
}

async function runAnimated() {
  await executeCode({ animated: true });
}

async function runFast() {
  await executeCode({ animated: false });
}
```

---

## File Changes

```
src/
  runtime.js           # NEW - Environment, SimpleFunction, ReturnValue, RuntimeError
  interpreter.js       # Simplified - uses classes from runtime.js
  main.js              # Refactored - executeCode helper, call stack callbacks
  memory-renderer.js   # Enhanced - call stack display
  examples.js          # Simplified - manager only, examples moved to separate files
  examples/
    tokenizer-demo.js  # NEW - Step-through tokenizer example
    variables.js       # NEW - Variable declaration example
    arithmetic.js      # NEW - Math operations example
    comparisons.js     # NEW - Boolean comparisons example
    functions.js       # NEW - Functions & call stack example
styles/
  interpreter.css      # Stack frame styling
tests/
  call-stack.spec.js   # NEW - call stack visualization tests
```

---

## Tests

### Call Stack Tests (tests/call-stack.spec.js)

1. **"global frame shown at start"**
   - Run: `let x = 1`
   - Memory shows `<global>` frame with `x: 1`

2. **"function call creates new frame"**
   - Run animated: `function foo() { }\nfoo()`
   - During call, memory shows `foo()` frame on top of `<global>`

3. **"function frame shows parameters"**
   - Run animated: `function add(a, b) { return a + b }\nadd(1, 2)`
   - Frame shows `a: 1`, `b: 2`

4. **"nested calls show multiple frames"**
   - Run animated: `function a() { b() }\nfunction b() { }\na()`
   - Shows `b()` → `a()` → `<global>` stack

5. **"recursive calls show growing stack"**
   - Run animated: `function f(n) { if (n > 0) { f(n-1) } }\nf(2)`
   - Stack grows: `f(0)` → `f(1)` → `f(2)` → `<global>`

6. **"frame removed on return"**
   - Run animated: `function foo() { return 1 }\nfoo()\nprint "after"`
   - After `foo()` returns, only `<global>` remains

7. **"stack cleared after execution"**
   - Run fast: `function foo() { }\nfoo()`
   - Memory shows final state with `<global>` only

---

## Deliverables

### Refactoring
- [x] Create src/runtime.js with extracted classes
- [x] Update src/interpreter.js to use runtime.js classes
- [x] Add onCallStart/onCallEnd callbacks to Interpreter
- [x] Create executeCode() helper in main.js
- [x] Refactor runAnimated/runFast to use executeCode()

### Call Stack Visualization
- [x] Add pushFrame/popFrame/setGlobalFrame to MemoryRenderer
- [x] Update MemoryRenderer.render() for stack display
- [x] Add CSS for stack frames
- [x] Wire up callbacks in executeCode()

### Tests
- [x] Create tests/call-stack.spec.js with 7 tests
- [x] All tests passing (184 total)

---

## Notes

**Why visualize the call stack:**
- Shows how function calls work (each call = new frame)
- Shows how local variables are scoped
- Shows how recursion creates many frames
- Prepares Connor for debugging real programs

**Stack grows down in display:**
- Most recent call at top (like most debuggers)
- Global frame always at bottom
- Each frame shows function name and local variables

---

## Status

**COMPLETE** - 184 tests passing

### Completed Deliverables

- [x] Created src/runtime.js with Environment, SimpleFunction, ReturnValue, RuntimeError
- [x] Updated src/interpreter.js to import from runtime.js (via browser globals)
- [x] Added onCallStart/onCallEnd callbacks to Interpreter
- [x] Created executeCode() helper in main.js - DRY refactor
- [x] Refactored runAnimated/runFast to use executeCode({ animated: true/false })
- [x] Updated MemoryRenderer with pushFrame/popFrame/setGlobalFrame/updateFrame
- [x] Added CSS for call stack display with stack frames
- [x] Created tests/call-stack.spec.js with 7 tests
- [x] Added runtime.js to index.html
- [x] Added "Functions & Call Stack" example program
- [x] Refactored examples into separate files (src/examples/*.js)
