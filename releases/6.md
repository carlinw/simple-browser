# Release 6: Interpreter - Numbers and Arithmetic

> Follow CLAUDE.md - do not implement until user approves complete release plan.

## Code Quality Analysis (from Release 5)

**Current codebase:** 3,660 lines across 15 files (8 src, 5 tests, 1 css, 1 html)

### Source Files
| File | Lines | Status |
|------|-------|--------|
| scanner.js | 398 | OK - state machine is inherently complex |
| lexer.js | 384 | OK |
| parser.js | 334 | OK - clean recursive descent |
| main.js | 316 | OK - previous long functions have been refactored |
| ast-renderer.js | 198 | OK - clean recursive rendering |
| reference.js | 117 | OK |
| visualizer.js | 101 | OK |
| examples.js | 59 | OK |

### Test Files
| File | Lines | Tests | Status |
|------|-------|-------|--------|
| lexer-viz.spec.js | 346 | 23 | OK |
| parser.spec.js | 242 | 20 | OK |
| ast.spec.js | 203 | 14 | OK |
| lexer.spec.js | 150 | 13 | OK |
| ui.spec.js | 133 | 13 | OK |

**Total: 83 tests passing**

### Issues to Address (MUST FIX)

1. **Duplicate code:** `isDigit()`, `isAlpha()`, `isAlphaNumeric()` exist in both lexer.js and scanner.js
   - **Action:** Extract to shared `src/utils.js` in this release

### Monitoring
- CSS file at 621 lines - consider splitting if it grows much more

---

## Goal

Begin the interpreter phase! This release adds the ability to actually **execute** code with **visual feedback**:
- Evaluate numeric expressions: `42`, `1 + 2`, `3 * 4 + 5`
- **Animate execution** by highlighting AST nodes as they're evaluated
- New button layout separating parsing from execution

Connor can now write math expressions and watch the interpreter walk through the AST!

## Features

### New Button Layout

```
[Language Syntax] [Example] [Parse] [Run] [Run Fast] [Step] [Reset]
```

| Button | Action |
|--------|--------|
| **Parse** | Tokenize and parse only. Shows Tokens and AST tabs. No execution. |
| **Run** | Parse + execute with animation. Highlights each AST node for 5 seconds as it's evaluated. |
| **Run Fast** | Parse + execute immediately with no animation. |
| **Step** | Character-by-character lexer stepping (existing functionality) |
| **Reset** | Return to edit mode (existing functionality) |

### AST Execution Visualization

When **Run** is clicked, the interpreter walks the AST and **highlights each node** as it's being evaluated:

1. Switch to AST tab automatically
2. Highlight the current node being evaluated (CSS class `ast-executing`)
3. Pause for 5 seconds (configurable)
4. Move to next node
5. When complete, switch to Output tab to show results

**Visual feedback:**
- Current node gets a glowing border/background
- Previously evaluated nodes could fade or show their computed value
- Output tab updates incrementally as values are computed

```css
/* Example styling */
.ast-executing {
  animation: pulse 0.5s ease-in-out infinite;
  box-shadow: 0 0 10px #4a7aff;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}
```

### Expression Evaluation

The interpreter will evaluate expressions and display the result:

```
Input: 2 + 3 * 4
Output: 14
```

```
Input: (2 + 3) * 4
Output: 20
```

### Supported Operations

| Operator | Description | Example | Result |
|----------|-------------|---------|--------|
| `+` | Addition | `2 + 3` | `5` |
| `-` | Subtraction | `5 - 2` | `3` |
| `*` | Multiplication | `3 * 4` | `12` |
| `/` | Division | `10 / 2` | `5` |
| `()` | Grouping | `(2 + 3) * 4` | `20` |

### Error Handling

- Division by zero: `"Error: Division by zero"`
- Non-numeric operands (for now): `"Error: Cannot perform arithmetic on non-numeric value"`

## Implementation

### Refactoring: Extract Character Utils (REQUIRED)

Create `src/utils.js` to eliminate duplicate code:

```javascript
// src/utils.js - Shared utility functions

function isDigit(char) {
  return char >= '0' && char <= '9';
}

function isAlpha(char) {
  return (char >= 'a' && char <= 'z') ||
         (char >= 'A' && char <= 'Z') ||
         char === '_';
}

function isAlphaNumeric(char) {
  return isAlpha(char) || isDigit(char);
}

// Export for use in other modules
window.CharUtils = { isDigit, isAlpha, isAlphaNumeric };
```

Update lexer.js and scanner.js to use `CharUtils.isDigit()` etc., removing their local implementations.

### Interpreter Class

```javascript
// src/interpreter.js
class Interpreter {
  constructor(options = {}) {
    this.onNodeEnter = options.onNodeEnter || (() => {});  // Callback for visualization
    this.onNodeExit = options.onNodeExit || (() => {});
    this.stepDelay = options.stepDelay || 0;  // ms between steps (0 = instant)
  }

  // Main entry point - evaluate a program (async for animation support)
  async interpret(ast) {
    const results = [];
    for (const statement of ast.statements) {
      const result = await this.execute(statement);
      if (result !== undefined && result !== null) {
        results.push(result);
      }
    }
    return {
      output: results,
      errors: []
    };
  }

  // Execute a statement
  async execute(node) {
    await this.enterNode(node);

    let result;
    switch (node.type) {
      case 'ExpressionStatement':
        result = await this.evaluate(node.expression);
        break;
      case 'PrintStatement':
        result = await this.evaluate(node.value);
        break;
      default:
        result = null;
    }

    await this.exitNode(node, result);
    return result;
  }

  // Evaluate an expression
  async evaluate(node) {
    await this.enterNode(node);

    let result;
    switch (node.type) {
      case 'NumberLiteral':
        result = node.value;
        break;

      case 'StringLiteral':
        result = node.value;
        break;

      case 'BooleanLiteral':
        result = node.value;
        break;

      case 'BinaryExpression':
        result = await this.evaluateBinary(node);
        break;

      case 'Identifier':
        throw new RuntimeError(`Undefined variable: ${node.name}`);

      default:
        throw new RuntimeError(`Unknown expression type: ${node.type}`);
    }

    await this.exitNode(node, result);
    return result;
  }

  // Evaluate binary expression
  async evaluateBinary(node) {
    const left = await this.evaluate(node.left);
    const right = await this.evaluate(node.right);

    if (typeof left !== 'number' || typeof right !== 'number') {
      if (node.operator === '+' && (typeof left === 'string' || typeof right === 'string')) {
        return String(left) + String(right);
      }
      throw new RuntimeError(`Cannot perform '${node.operator}' on non-numeric values`);
    }

    switch (node.operator) {
      case '+': return left + right;
      case '-': return left - right;
      case '*': return left * right;
      case '/':
        if (right === 0) throw new RuntimeError('Division by zero');
        return left / right;
      case '<': return left < right;
      case '>': return left > right;
      case '<=': return left <= right;
      case '>=': return left >= right;
      case '==': return left === right;
      case '!=': return left !== right;
      default:
        throw new RuntimeError(`Unknown operator: ${node.operator}`);
    }
  }

  // Visualization hooks
  async enterNode(node) {
    this.onNodeEnter(node);
    if (this.stepDelay > 0) {
      await this.delay(this.stepDelay);
    }
  }

  async exitNode(node, result) {
    this.onNodeExit(node, result);
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

class RuntimeError extends Error {
  constructor(message) {
    super(message);
    this.name = 'RuntimeError';
  }
}
```

### AST Renderer Updates

Add methods to highlight nodes during execution:

```javascript
// In ast-renderer.js
class ASTRenderer {
  constructor(container) {
    this.container = container;
    this.nodeElements = new Map();  // Map AST node -> DOM element
  }

  render(ast) {
    this.container.innerHTML = '';
    this.nodeElements.clear();
    // ... existing render logic ...
    // Store reference: this.nodeElements.set(node, nodeBox);
  }

  // Highlight a node during execution
  highlightNode(node) {
    // Remove previous highlight
    this.container.querySelectorAll('.ast-executing').forEach(el => {
      el.classList.remove('ast-executing');
    });

    // Add highlight to current node
    const element = this.nodeElements.get(node);
    if (element) {
      element.classList.add('ast-executing');
      element.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }

  // Clear all highlights
  clearHighlights() {
    this.container.querySelectorAll('.ast-executing').forEach(el => {
      el.classList.remove('ast-executing');
    });
  }
}
```

### Main.js Updates

```javascript
// New button handlers

// Parse button - tokenize and parse only
function parseOnly() {
  const source = codeEditor.value;
  if (!source.trim()) {
    tabTokens.textContent = '';
    tabAst.innerHTML = '';
    tabOutput.textContent = 'Hello, Connor!';
    switchTab('output');
    return;
  }

  // Tokenize
  const lex = new Lexer(source);
  const lexResult = lex.tokenize();
  renderTokens(lexResult.tokens);

  // Parse
  const parser = new Parser(lexResult.tokens);
  const parseResult = parser.parse();
  astRenderer.render(parseResult.ast);

  // Show errors if any, otherwise show AST
  if (lexResult.errors.length > 0 || parseResult.errors.length > 0) {
    renderErrors(lexResult.errors, parseResult.errors, []);
    switchTab('output');
  } else {
    switchTab('ast');
  }
}

// Run button - parse + execute with animation (5 second steps)
async function runAnimated() {
  await parseOnly();  // First parse

  // Get the AST
  const parseResult = /* get from parseOnly or re-parse */;
  if (parseResult.errors.length > 0) return;

  switchTab('ast');

  const interpreter = new Interpreter({
    stepDelay: 5000,  // 5 seconds per node
    onNodeEnter: (node) => astRenderer.highlightNode(node),
    onNodeExit: (node, result) => { /* optionally show result */ }
  });

  try {
    const result = await interpreter.interpret(parseResult.ast);
    astRenderer.clearHighlights();
    renderOutput(result.output);
    switchTab('output');
  } catch (error) {
    astRenderer.clearHighlights();
    renderErrors([], [], [{ message: error.message }]);
    switchTab('output');
  }
}

// Run Fast button - parse + execute immediately
async function runFast() {
  await parseOnly();  // First parse

  const parseResult = /* get from parseOnly or re-parse */;
  if (parseResult.errors.length > 0) return;

  const interpreter = new Interpreter({ stepDelay: 0 });

  try {
    const result = await interpreter.interpret(parseResult.ast);
    renderOutput(result.output);
    switchTab('output');
  } catch (error) {
    renderErrors([], [], [{ message: error.message }]);
    switchTab('output');
  }
}
```

### HTML Updates

```html
<nav id="toolbar">
  <div class="toolbar-left">
    <button id="help-btn">Language Syntax</button>
    <button id="example-btn">Example</button>
    <button id="parse-btn">Parse</button>
    <button id="run-btn">Run</button>
    <button id="run-fast-btn">Run Fast</button>
    <button id="step-btn">Step</button>
    <button id="reset-btn" disabled>Reset</button>
  </div>
</nav>
```

### CSS Updates

```css
/* Execution visualization */
.ast-executing {
  animation: ast-pulse 0.8s ease-in-out infinite;
  box-shadow: 0 0 12px 4px rgba(74, 122, 255, 0.6);
  border-color: #4a7aff !important;
}

@keyframes ast-pulse {
  0%, 100% {
    box-shadow: 0 0 12px 4px rgba(74, 122, 255, 0.6);
  }
  50% {
    box-shadow: 0 0 20px 8px rgba(74, 122, 255, 0.8);
  }
}

/* Button styling for new buttons */
#parse-btn {
  background: #17a2b8;
  color: white;
}

#parse-btn:hover:not(:disabled) {
  background: #138496;
}

#run-fast-btn {
  background: #fd7e14;
  color: white;
}

#run-fast-btn:hover:not(:disabled) {
  background: #e96b02;
}
```

## File Structure

```
src/
  utils.js         # NEW - shared character utilities (REQUIRED)
  interpreter.js   # NEW - expression evaluator with animation support
  lexer.js         # Updated - use CharUtils
  scanner.js       # Updated - use CharUtils
  parser.js        # Existing
  ast-renderer.js  # Updated - add highlighting methods
  main.js          # Updated - new button handlers
  visualizer.js    # Existing
  reference.js     # Existing
  examples.js      # Existing
styles/
  main.css         # Updated - execution animation styles
```

## Playwright Tests

### UI Tests (new buttons)

1. **"parse button exists"**
   - Verify `#parse-btn` exists with text "Parse"

2. **"run fast button exists"**
   - Verify `#run-fast-btn` exists with text "Run Fast"

3. **"parse button shows AST without execution"**
   - Input: `2 + 3`
   - Click Parse
   - Verify AST tab is active
   - Verify Output tab does NOT contain `5`

4. **"run fast executes immediately"**
   - Input: `2 + 3`
   - Click Run Fast
   - Verify Output contains `5`

### Interpreter Tests

5. **"interpreter evaluates number literal"**
   - Input: `42`
   - Click Run Fast
   - Verify output contains `42`

6. **"interpreter evaluates addition"**
   - Input: `2 + 3`
   - Verify output contains `5`

7. **"interpreter evaluates subtraction"**
   - Input: `10 - 4`
   - Verify output contains `6`

8. **"interpreter evaluates multiplication"**
   - Input: `3 * 4`
   - Verify output contains `12`

9. **"interpreter evaluates division"**
   - Input: `20 / 4`
   - Verify output contains `5`

10. **"interpreter respects operator precedence"**
    - Input: `2 + 3 * 4`
    - Verify output contains `14`

11. **"interpreter respects parentheses"**
    - Input: `(2 + 3) * 4`
    - Verify output contains `20`

12. **"interpreter handles complex expressions"**
    - Input: `1 + 2 * 3 - 4 / 2`
    - Verify output contains `5`

13. **"interpreter evaluates comparison to boolean"**
    - Input: `5 > 3`
    - Verify output contains `true`

14. **"interpreter evaluates equality to boolean"**
    - Input: `5 == 5`
    - Verify output contains `true`

15. **"print statement shows output"**
    - Input: `print 42`
    - Verify output contains `42`

16. **"multiple expressions show multiple outputs"**
    - Input: `1 + 2\n3 * 4`
    - Verify output contains `3` and `12`

17. **"string concatenation works"**
    - Input: `"hello" + " " + "world"`
    - Verify output contains `hello world`

### Visualization Tests

18. **"run button highlights AST nodes"**
    - Input: `2 + 3`
    - Click Run
    - Verify `.ast-executing` class appears on a node

19. **"AST tab is active during animated run"**
    - Input: `2 + 3`
    - Click Run
    - Verify AST tab is active (before completion)

### Negative Tests

20. **"division by zero shows error"**
    - Input: `10 / 0`
    - Verify output contains `Division by zero`

21. **"undefined variable shows error"**
    - Input: `x + 1`
    - Verify output contains `Undefined variable`

22. **"arithmetic on non-numbers shows error"**
    - Input: `"hello" - 5`
    - Verify output contains error about non-numeric

## Deliverables

- [x] Create src/utils.js with shared character utilities
- [x] Update src/lexer.js to use CharUtils (remove duplicate methods)
- [x] Update src/scanner.js to use CharUtils (remove duplicate methods)
- [x] Create src/interpreter.js with async Interpreter class
- [x] Update src/ast-renderer.js with highlighting methods
- [x] Update src/main.js with new button handlers
- [x] Update index.html with Parse, Run, Run Fast buttons
- [x] Update styles/main.css with execution animation
- [x] tests/interpreter.spec.js with 22 tests
- [x] All tests passing (105 total: 83 existing + 22 new)

## Notes for Future Releases

> **Stack Visualizer Reminder:** When implementing the stack visualizer (Release 8), remember to show variables currently in scope. This should display which variables are accessible at each point during execution.

> **AST Type Representation:** In a future release, represent variable types more explicitly in the AST visualization. This could show type information (number, string, boolean) alongside values to help Connor understand the type system.

## Status

**COMPLETE**
