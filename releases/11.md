# Release 11: Functions

> Follow CLAUDE.md - do not implement until user approves complete release plan.

## Code Quality Analysis

**Current codebase:** 5,731 lines across 29 files (14 src, 12 tests, 3 css, 1 html)
**Tests:** 165 passing

### File Size Review

| File | Lines | Status |
|------|-------|--------|
| interpreter.css | 524 | MONITOR - approaching 600 threshold |
| lexer.js | 390 | OK |
| scanner.js | 384 | OK |
| parser.js | 381 | OK |
| main.js | 341 | OK |
| ast-renderer.js | 277 | OK |
| interpreter.js | 245 | OK |

### DRY Analysis

**Potential duplication in main.js:**

`runAnimated()` and `runFast()` share similar patterns:
- Both call `parseOnly()` and check result
- Both create interpreter with `onPrint` callback
- Both handle try/catch for execution

**Recommendation:** DEFER - The duplication is minor (< 10 lines). Extracting a helper would add complexity without significant benefit. The functions have different enough behavior (animation, timing, UI state) that keeping them separate is clearer.

**Parser consume patterns:**

Repeated patterns like `this.consume('PUNCTUATION', '(', ...)` are intentional - each call has different error messages. Not a DRY violation.

### Encapsulation Analysis

**DOM access:** Centralized in `main.js` at initialization. All renderers receive their container elements via constructor. âœ“ Good encapsulation.

**State management:** `state`, `scanner`, `currentParseResult` are module-level in main.js. Appropriate for this app size.

**Interpreter callbacks:** Well-encapsulated - `onNodeEnter`, `onNodeExit`, `onVariableChange`, `onPrint` allow UI to observe without coupling.

### Issues to Address

| Priority | Issue | Action |
|----------|-------|--------|
| **MONITOR** | interpreter.css at 524 lines | Consider splitting if grows past 600 |
| **OK** | main.js runAnimated/runFast duplication | Defer - complexity not worth extracting |

No critical issues. Codebase is healthy.

---

## Goals

Add user-defined functions with:
- Function declaration (`function name(params) { body }`)
- Function calls (`name(args)`)
- Return statements (`return value`)
- Local scope (parameters and local variables)

This is a significant feature that enables recursion and code reuse.

## Current State

- Parser recognizes `function` and `return` keywords (from lexer KEYWORDS)
- No parsing or interpretation of functions yet
- Interpreter has flat Environment (no scope chain)

---

## Language Syntax (this release)

### Function Declaration

```
function name(param1, param2) {
  // body
}
```

- Zero or more parameters
- Parameters are local to the function
- Functions can access outer variables (closure - simple version)

### Function Call

```
name(arg1, arg2)
```

- Arguments are evaluated left-to-right
- Number of arguments must match parameters (for simplicity)

### Return Statement

```
return expression
```

- Returns a value from the function
- If no return, function returns `null`
- Return immediately exits the function

### Examples

```
// Simple function
function greet(name) {
  print "Hello, " + name
}
greet("Connor")

// Function with return
function add(a, b) {
  return a + b
}
print add(2, 3)

// Recursive function
function factorial(n) {
  if (n <= 1) {
    return 1
  }
  return n * factorial(n - 1)
}
print factorial(5)
```

---

## Implementation

### Parser Changes

#### 1. Parse Function Declaration

Add to `parseStatement()`:
```javascript
if (this.match('KEYWORD', 'function')) {
  return this.parseFunctionDeclaration();
}
```

```javascript
parseFunctionDeclaration() {
  const funcToken = this.previous();
  const nameToken = this.consume('IDENTIFIER', null, "Expected function name");

  this.consume('PUNCTUATION', '(', "Expected '(' after function name");

  const params = [];
  if (!this.check('PUNCTUATION', ')')) {
    do {
      const param = this.consume('IDENTIFIER', null, "Expected parameter name");
      params.push(param.value);
    } while (this.match('PUNCTUATION', ','));
  }

  this.consume('PUNCTUATION', ')', "Expected ')' after parameters");

  const body = this.parseBlock();

  return {
    type: 'FunctionDeclaration',
    name: nameToken.value,
    params: params,
    body: body,
    token: funcToken,
    endToken: this.previous()
  };
}
```

#### 2. Parse Return Statement

Add to `parseStatement()`:
```javascript
if (this.match('KEYWORD', 'return')) {
  return this.parseReturnStatement();
}
```

```javascript
parseReturnStatement() {
  const returnToken = this.previous();
  let value = null;

  // Check if there's an expression to return
  if (!this.check('PUNCTUATION', '}') && !this.isAtEnd()) {
    value = this.parseExpression();
  }

  return {
    type: 'ReturnStatement',
    value: value,
    token: returnToken,
    endToken: this.previous()
  };
}
```

#### 3. Parse Function Call

In `parsePrimary()`, after parsing an identifier, check for `(`:
```javascript
if (this.check('IDENTIFIER')) {
  const token = this.advance();

  // Check if this is a function call
  if (this.check('PUNCTUATION', '(')) {
    return this.parseCallExpression(token);
  }

  return { type: 'Identifier', name: token.value, token: token };
}
```

```javascript
parseCallExpression(nameToken) {
  this.consume('PUNCTUATION', '(', "Expected '('");

  const args = [];
  if (!this.check('PUNCTUATION', ')')) {
    do {
      args.push(this.parseExpression());
    } while (this.match('PUNCTUATION', ','));
  }

  const closeParen = this.consume('PUNCTUATION', ')', "Expected ')' after arguments");

  return {
    type: 'CallExpression',
    callee: nameToken.value,
    arguments: args,
    token: nameToken,
    endToken: closeParen
  };
}
```

### Interpreter Changes

#### 1. Scoped Environment

Modify Environment to support parent scopes:
```javascript
class Environment {
  constructor(parent = null) {
    this.values = new Map();
    this.parent = parent;
  }

  define(name, value) {
    this.values.set(name, value);
  }

  get(name) {
    if (this.values.has(name)) {
      return this.values.get(name);
    }
    if (this.parent) {
      return this.parent.get(name);
    }
    throw new RuntimeError(`Undefined variable: ${name}`);
  }

  assign(name, value) {
    if (this.values.has(name)) {
      this.values.set(name, value);
      return;
    }
    if (this.parent) {
      this.parent.assign(name, value);
      return;
    }
    throw new RuntimeError(`Undefined variable: ${name}`);
  }
}
```

#### 2. Function Value Class

```javascript
class SimpleFunction {
  constructor(declaration, closure) {
    this.declaration = declaration;
    this.closure = closure;  // Environment where function was defined
  }
}
```

#### 3. Return Exception

Use an exception to unwind the call stack on return:
```javascript
class ReturnValue {
  constructor(value) {
    this.value = value;
  }
}
```

#### 4. Execute Function Declaration

```javascript
case 'FunctionDeclaration': {
  const func = new SimpleFunction(node, this.environment);
  this.environment.define(node.name, func);
  this.onVariableChange(node.name, '[function]', 'define');
  break;
}
```

#### 5. Execute Return Statement

```javascript
case 'ReturnStatement': {
  let value = null;
  if (node.value) {
    value = await this.evaluate(node.value);
  }
  throw new ReturnValue(value);
}
```

#### 6. Evaluate Call Expression

```javascript
case 'CallExpression': {
  const callee = this.environment.get(node.callee);

  if (!(callee instanceof SimpleFunction)) {
    throw new RuntimeError(`'${node.callee}' is not a function`);
  }

  const args = [];
  for (const arg of node.arguments) {
    args.push(await this.evaluate(arg));
  }

  if (args.length !== callee.declaration.params.length) {
    throw new RuntimeError(
      `Expected ${callee.declaration.params.length} arguments but got ${args.length}`
    );
  }

  // Create new environment for function execution
  const funcEnv = new Environment(callee.closure);

  // Bind parameters
  for (let i = 0; i < callee.declaration.params.length; i++) {
    funcEnv.define(callee.declaration.params[i], args[i]);
  }

  // Execute function body
  const previousEnv = this.environment;
  this.environment = funcEnv;

  try {
    await this.execute(callee.declaration.body);
    result = null;  // No explicit return
  } catch (e) {
    if (e instanceof ReturnValue) {
      result = e.value;
    } else {
      throw e;
    }
  } finally {
    this.environment = previousEnv;
  }
  break;
}
```

### AST Renderer Changes

Add rendering for new node types:
- FunctionDeclaration: show name, params, body
- CallExpression: show callee, arguments
- ReturnStatement: show value

---

## Tests

### Function Tests (tests/functions.spec.js)

1. **"function declaration creates function"**
   - Run: `function greet() { }\nprint "done"`
   - Output: `done` (no error)

2. **"function call executes body"**
   - Run: `function sayHi() { print "hi" }\nsayHi()`
   - Output: `hi`

3. **"function with parameters"**
   - Run: `function greet(name) { print "Hello " + name }\ngreet("Connor")`
   - Output: `Hello Connor`

4. **"function with return value"**
   - Run: `function add(a, b) { return a + b }\nprint add(2, 3)`
   - Output: `5`

5. **"function with multiple parameters"**
   - Run: `function sum3(a, b, c) { return a + b + c }\nprint sum3(1, 2, 3)`
   - Output: `6`

6. **"function return exits early"**
   - Run: `function test() { return 1\nprint "never" }\nprint test()`
   - Output: `1` (not "never")

7. **"function without return returns null"**
   - Run: `function noReturn() { let x = 1 }\nprint noReturn()`
   - Output: `null`

8. **"recursive function works"**
   - Run: `function fib(n) { if (n <= 1) { return n } return fib(n-1) + fib(n-2) }\nprint fib(6)`
   - Output: `8`

9. **"function parameters are local"**
   - Run: `let x = 1\nfunction setX(x) { x = 99 }\nsetX(5)\nprint x`
   - Output: `1` (outer x unchanged)

10. **"function can access outer variables"**
    - Run: `let x = 10\nfunction getX() { return x }\nprint getX()`
    - Output: `10`

11. **"calling non-function shows error"**
    - Run: `let x = 5\nx()`
    - Error: `'x' is not a function`

12. **"wrong argument count shows error"**
    - Run: `function f(a) { }\nf(1, 2)`
    - Error: `Expected 1 arguments but got 2`

---

## File Changes

```
src/
  interpreter.js     # Add scoped Environment, SimpleFunction, ReturnValue,
                     # FunctionDeclaration, ReturnStatement, CallExpression
  parser.js          # Add parseFunctionDeclaration, parseReturnStatement,
                     # parseCallExpression
  ast-renderer.js    # Add rendering for FunctionDeclaration, CallExpression,
                     # ReturnStatement
tests/
  functions.spec.js  # NEW - 12 tests for functions
```

---

## Deliverables

- [ ] Parser: parseFunctionDeclaration()
- [ ] Parser: parseReturnStatement()
- [ ] Parser: parseCallExpression()
- [ ] Interpreter: Scoped Environment with parent chain
- [ ] Interpreter: SimpleFunction class
- [ ] Interpreter: ReturnValue exception class
- [ ] Interpreter: FunctionDeclaration execution
- [ ] Interpreter: ReturnStatement execution
- [ ] Interpreter: CallExpression evaluation
- [ ] AST Renderer: New node types
- [ ] Create tests/functions.spec.js with 12 tests
- [ ] All tests passing (177+ total)

---

## Notes

**Why use an exception for return:**
Using an exception to implement return is a common technique in tree-walking interpreters. It cleanly unwinds any nested blocks or loops back to the function call site.

**Closures:**
This implementation supports simple closures - functions can access variables from their defining scope. This enables patterns like:
```
let counter = 0
function increment() {
  counter = counter + 1
  return counter
}
print increment()  // 1
print increment()  // 2
```

**Future enhancements:**
- Anonymous functions (lambdas)
- First-class functions (passing functions as arguments)
- Higher-order functions (map, filter, etc.)

---

## Status

**COMPLETE** - 177 tests passing

### Completed Deliverables

- [x] Parser: parseFunctionDeclaration()
- [x] Parser: parseReturnStatement()
- [x] Parser: parseCallExpression()
- [x] Interpreter: Scoped Environment with parent chain
- [x] Interpreter: SimpleFunction class
- [x] Interpreter: ReturnValue exception class
- [x] Interpreter: FunctionDeclaration execution
- [x] Interpreter: ReturnStatement execution
- [x] Interpreter: CallExpression evaluation
- [x] AST Renderer: New node types (FunctionDeclaration, ReturnStatement, CallExpression, ParamList)
- [x] Create tests/functions.spec.js with 12 tests
- [x] All tests passing (177 total)
