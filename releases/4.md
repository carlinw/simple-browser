# Release 4: Parser (AST Construction)

> Follow CLAUDE.md - do not implement until user approves complete release plan.

## Goal

Build a parser that converts tokens into an Abstract Syntax Tree (AST). This is the second stage of the interpreter pipeline: source code → tokens → **AST** → execution.

The parser will:
- Read tokens from the lexer
- Construct a tree representing the program structure
- Handle operator precedence and associativity
- Report syntax errors with line/column information

No visualization yet - that's Release 5.

## Language Syntax (this release)

### Expressions

| Syntax | Description | Example |
|--------|-------------|---------|
| `number` | Integer literal | `42` |
| `string` | String literal | `"hello"` |
| `identifier` | Variable reference | `x` |
| `true` / `false` | Boolean literals | `true` |
| `(expr)` | Grouped expression | `(x + 1)` |
| `expr op expr` | Binary operation | `x + 1` |

### Operators (by precedence, lowest to highest)

| Precedence | Operators | Associativity |
|------------|-----------|---------------|
| 1 | `==` `!=` | Left |
| 2 | `<` `>` `<=` `>=` | Left |
| 3 | `+` `-` | Left |
| 4 | `*` `/` | Left |

### Statements

| Syntax | Description | Example |
|--------|-------------|---------|
| `let id = expr` | Variable declaration | `let x = 42` |
| `id = expr` | Assignment | `x = 10` |
| `print expr` | Output | `print x + 1` |
| `if (expr) { stmts }` | Conditional | `if (x > 0) { print x }` |
| `if (expr) { stmts } else { stmts }` | Conditional with else | `if (x > 0) { print "yes" } else { print "no" }` |
| `while (expr) { stmts }` | Loop | `while (x > 0) { x = x - 1 }` |

### Grammar (BNF-style)

```
program     = statement*

statement   = letStmt | assignStmt | printStmt | ifStmt | whileStmt | block

letStmt     = "let" IDENTIFIER "=" expression
assignStmt  = IDENTIFIER "=" expression
printStmt   = "print" expression
ifStmt      = "if" "(" expression ")" block ("else" block)?
whileStmt   = "while" "(" expression ")" block
block       = "{" statement* "}"

expression  = equality
equality    = comparison (("==" | "!=") comparison)*
comparison  = term (("<" | ">" | "<=" | ">=") term)*
term        = factor (("+" | "-") factor)*
factor      = unary (("*" | "/") unary)*
unary       = primary
primary     = NUMBER | STRING | "true" | "false" | IDENTIFIER | "(" expression ")"
```

## AST Node Types

### Expression Nodes

```javascript
// Number literal
{ type: 'NumberLiteral', value: 42 }

// String literal
{ type: 'StringLiteral', value: 'hello' }

// Boolean literal
{ type: 'BooleanLiteral', value: true }

// Variable reference
{ type: 'Identifier', name: 'x' }

// Binary operation
{
  type: 'BinaryExpression',
  operator: '+',
  left: { type: 'Identifier', name: 'x' },
  right: { type: 'NumberLiteral', value: 1 }
}

// Grouped expression (parens) - just returns inner expression
```

### Statement Nodes

```javascript
// Variable declaration
{
  type: 'LetStatement',
  name: 'x',
  value: { type: 'NumberLiteral', value: 42 }
}

// Assignment
{
  type: 'AssignStatement',
  name: 'x',
  value: { type: 'NumberLiteral', value: 10 }
}

// Print
{
  type: 'PrintStatement',
  value: { type: 'Identifier', name: 'x' }
}

// If statement
{
  type: 'IfStatement',
  condition: { type: 'BinaryExpression', ... },
  thenBranch: { type: 'Block', statements: [...] },
  elseBranch: { type: 'Block', statements: [...] } | null
}

// While loop
{
  type: 'WhileStatement',
  condition: { type: 'BinaryExpression', ... },
  body: { type: 'Block', statements: [...] }
}

// Block
{
  type: 'Block',
  statements: [...]
}

// Program (root node)
{
  type: 'Program',
  statements: [...]
}
```

## Implementation

### Parser Class

```javascript
class Parser {
  constructor(tokens) {
    this.tokens = tokens;
    this.pos = 0;
    this.errors = [];
  }

  // Main entry point
  parse() {
    const statements = [];
    while (!this.isAtEnd()) {
      const stmt = this.parseStatement();
      if (stmt) statements.push(stmt);
    }
    return {
      ast: { type: 'Program', statements },
      errors: this.errors
    };
  }

  // Token navigation
  peek() { ... }
  advance() { ... }
  check(type) { ... }
  match(...types) { ... }
  consume(type, message) { ... }
  isAtEnd() { ... }

  // Parsing methods (recursive descent)
  parseStatement() { ... }
  parseLetStatement() { ... }
  parseAssignStatement() { ... }
  parsePrintStatement() { ... }
  parseIfStatement() { ... }
  parseWhileStatement() { ... }
  parseBlock() { ... }
  parseExpression() { ... }
  parseEquality() { ... }
  parseComparison() { ... }
  parseTerm() { ... }
  parseFactor() { ... }
  parsePrimary() { ... }
}
```

### Integration with UI

When Run is clicked:
1. Tokenize source → tokens
2. Parse tokens → AST
3. Display AST as formatted JSON in output

```
AST:
{
  "type": "Program",
  "statements": [
    {
      "type": "LetStatement",
      "name": "x",
      "value": {
        "type": "NumberLiteral",
        "value": 42
      }
    },
    ...
  ]
}
```

### Error Handling

Parser errors should include:
- Error message
- Line and column (from token)
- What was expected vs. found

Example:
```
Error at line 1, column 8: Expected '=' after variable name, found 'IDENTIFIER'
```

## File Structure

```
src/
  lexer.js      # Existing
  scanner.js    # Existing
  parser.js     # NEW - Parser class
  main.js       # Updated - integrate parser
```

## Playwright Tests

### Positive Tests

1. **"parser parses number literal"**
   - Input: `42`
   - Verify AST contains NumberLiteral with value 42

2. **"parser parses string literal"**
   - Input: `"hello"`
   - Verify AST contains StringLiteral

3. **"parser parses boolean literals"**
   - Input: `true` and `false`
   - Verify AST contains BooleanLiteral

4. **"parser parses variable declaration"**
   - Input: `let x = 42`
   - Verify AST contains LetStatement

5. **"parser parses assignment"**
   - Input: `x = 10`
   - Verify AST contains AssignStatement

6. **"parser parses print statement"**
   - Input: `print x`
   - Verify AST contains PrintStatement

7. **"parser parses arithmetic expressions"**
   - Input: `1 + 2 * 3`
   - Verify correct precedence (multiply before add)

8. **"parser parses comparison expressions"**
   - Input: `x > 0`
   - Verify AST contains BinaryExpression with operator '>'

9. **"parser parses equality expressions"**
   - Input: `x == 1`
   - Verify AST contains BinaryExpression with operator '=='

10. **"parser parses grouped expressions"**
    - Input: `(1 + 2) * 3`
    - Verify grouping overrides default precedence

11. **"parser parses if statement"**
    - Input: `if (x > 0) { print x }`
    - Verify AST contains IfStatement

12. **"parser parses if-else statement"**
    - Input: `if (x > 0) { print "yes" } else { print "no" }`
    - Verify AST contains IfStatement with elseBranch

13. **"parser parses while loop"**
    - Input: `while (x > 0) { x = x - 1 }`
    - Verify AST contains WhileStatement

14. **"parser parses multiple statements"**
    - Input: `let x = 1\nlet y = 2\nprint x + y`
    - Verify AST contains 3 statements

15. **"parser handles operator precedence"**
    - Input: `1 + 2 * 3 - 4 / 2`
    - Verify correct tree structure

### Negative Tests

16. **"parser reports missing equals in let"**
    - Input: `let x 42`
    - Verify error message about missing '='

17. **"parser reports missing expression after operator"**
    - Input: `x +`
    - Verify error message

18. **"parser reports missing closing paren"**
    - Input: `(1 + 2`
    - Verify error message about missing ')'

19. **"parser reports missing block braces"**
    - Input: `if (x > 0) print x`
    - Verify error message about missing '{'

20. **"parser reports unexpected token"**
    - Input: `let = 42`
    - Verify error message

## Deliverables

- [x] Create src/parser.js with Parser class
- [x] Update src/main.js to integrate parser
- [x] Update index.html to include parser.js
- [x] Run button shows AST output
- [x] tests/parser.spec.js with 20 tests
- [x] All tests passing (63 total: 7 UI + 13 lexer + 23 lexer-viz + 20 parser)

## Code Quality Notes from Release 3

Issues to consider:
1. lexer.js and scanner.js have duplicate character-checking methods - could extract to shared utils
2. For now, parser will use Lexer directly (Run mode) since we only need tokens, not character-by-character

## Status

**COMPLETE**
