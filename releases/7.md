# Release 7: Interpreter - Variables and Assignment

> Follow CLAUDE.md - do not implement until user approves complete release plan.

## Code Quality Analysis (from Release 6)

**Current codebase:** 4,245 lines across 16 files (10 src, 6 tests, 1 css, 1 html)

### Source Files
| File | Lines | Status |
|------|-------|--------|
| main.js | 432 | MONITOR - getting large, may need refactoring soon |
| scanner.js | 384 | OK - state machine is inherently complex |
| lexer.js | 370 | OK |
| parser.js | 334 | OK - clean recursive descent |
| ast-renderer.js | 225 | OK |
| interpreter.js | 160 | OK - will grow this release |
| reference.js | 117 | OK |
| visualizer.js | 101 | OK |
| examples.js | 59 | OK |
| utils.js | 19 | OK |

### Test Files
| File | Lines | Tests | Status |
|------|-------|-------|--------|
| lexer-viz.spec.js | 346 | 23 | OK |
| parser.spec.js | 242 | 20 | OK |
| interpreter.spec.js | 219 | 22 | OK |
| ast.spec.js | 203 | 14 | OK |
| ui.spec.js | 166 | 15 | OK |
| lexer.spec.js | 150 | 13 | OK |

**Total: 107 tests passing**

### Issues to Address

1. **main.js size:** At 432 lines, this file is approaching the threshold for splitting. Consider extracting button handlers or render functions into separate modules in a future release.

### Monitoring
- CSS file at 656 lines - splitting may be needed if it grows further

### Code Quality Wins
- Duplicate code eliminated (CharUtils in utils.js)
- Clean separation: Lexer, Scanner, Parser, Interpreter each have distinct responsibilities
- Async/await pattern in interpreter enables animation without blocking

---

## Goal

Add **variable support** to the interpreter! This release enables:
- Declaring variables with `let x = value`
- Using variables in expressions `x + 1`
- Reassigning variables `x = newValue`

Connor can now write programs that store and manipulate data!

## Features

### Variable Declaration

```
let name = "Connor"
let count = 42
let isReady = true
```

Variables are declared with `let` and must be initialized.

### Variable Usage

Variables can be used in any expression:

```
let x = 10
let y = 20
print x + y    // Output: 30
```

### Variable Assignment

Variables can be reassigned:

```
let count = 1
count = count + 1
print count    // Output: 2
```

### Scope Rules (Simple for now)

For this release, all variables are **global**:
- Variables are visible everywhere after declaration
- No block scope yet (that comes with if/else and functions)

This keeps implementation simple while teaching the core concept.

## Implementation

### Environment Class

Store variable bindings:

```javascript
// src/environment.js (or add to interpreter.js)
class Environment {
  constructor() {
    this.values = new Map();
  }

  define(name, value) {
    this.values.set(name, value);
  }

  get(name) {
    if (this.values.has(name)) {
      return this.values.get(name);
    }
    throw new RuntimeError(`Undefined variable: ${name}`);
  }

  assign(name, value) {
    if (this.values.has(name)) {
      this.values.set(name, value);
      return;
    }
    throw new RuntimeError(`Undefined variable: ${name}`);
  }

  has(name) {
    return this.values.has(name);
  }
}
```

### Interpreter Updates

Update the interpreter to handle variables:

```javascript
class Interpreter {
  constructor(options = {}) {
    // ... existing code ...
    this.environment = new Environment();
  }

  async execute(node) {
    await this.enterNode(node);

    let result;
    switch (node.type) {
      // ... existing cases ...

      case 'LetStatement':
        const letValue = await this.evaluate(node.value);
        this.environment.define(node.name.name, letValue);
        result = letValue;
        break;

      case 'AssignStatement':
        const assignValue = await this.evaluate(node.value);
        this.environment.assign(node.name.name, assignValue);
        result = assignValue;
        break;

      // ... rest of cases ...
    }

    await this.exitNode(node, result);
    return result;
  }

  async evaluate(node) {
    // ... existing code ...

    switch (node.type) {
      // ... existing cases ...

      case 'Identifier':
        result = this.environment.get(node.name);
        break;

      // ... rest of cases ...
    }

    // ... existing code ...
  }
}
```

### Reset Environment

When resetting or starting a new run:

```javascript
// In main.js or interpreter setup
function reset() {
  // ... existing reset code ...
  // Environment is created fresh with each new Interpreter instance
}
```

## File Changes

```
src/
  interpreter.js   # Add Environment class, update execute/evaluate
```

Only one file needs modification.

## Playwright Tests

### Variable Declaration Tests

1. **"interpreter declares and uses variable"**
   - Input: `let x = 42\nprint x`
   - Verify output contains `42`

2. **"interpreter declares string variable"**
   - Input: `let name = "Connor"\nprint name`
   - Verify output contains `Connor`

3. **"interpreter declares boolean variable"**
   - Input: `let flag = true\nprint flag`
   - Verify output contains `true`

4. **"interpreter uses variable in expression"**
   - Input: `let x = 10\nlet y = 20\nprint x + y`
   - Verify output contains `30`

5. **"interpreter uses variable in complex expression"**
   - Input: `let a = 2\nlet b = 3\nlet c = 4\nprint a + b * c`
   - Verify output contains `14`

### Variable Assignment Tests

6. **"interpreter assigns to variable"**
   - Input: `let x = 1\nx = 2\nprint x`
   - Verify output contains `2`

7. **"interpreter assigns expression to variable"**
   - Input: `let x = 10\nx = x + 5\nprint x`
   - Verify output contains `15`

8. **"interpreter increments variable"**
   - Input: `let count = 0\ncount = count + 1\ncount = count + 1\nprint count`
   - Verify output contains `2`

9. **"interpreter assigns string to variable"**
   - Input: `let msg = "hello"\nmsg = "world"\nprint msg`
   - Verify output contains `world`

### Multiple Variables Tests

10. **"interpreter handles multiple variables"**
    - Input: `let a = 1\nlet b = 2\nlet c = 3\nprint a + b + c`
    - Verify output contains `6`

11. **"interpreter uses variables in comparison"**
    - Input: `let x = 10\nlet y = 5\nprint x > y`
    - Verify output contains `true`

12. **"interpreter concatenates string variables"**
    - Input: `let first = "Hello"\nlet second = " World"\nprint first + second`
    - Verify output contains `Hello World`

### Negative Tests

13. **"undefined variable shows error"**
    - Input: `print x`
    - Verify output contains `Undefined variable: x`

14. **"assignment to undefined variable shows error"**
    - Input: `x = 10`
    - Verify output contains `Undefined variable: x`

15. **"cannot use variable before declaration"**
    - Input: `print x\nlet x = 5`
    - Verify output contains `Undefined variable: x`

## Deliverables

- [ ] Add Environment class to src/interpreter.js
- [ ] Update Interpreter.execute() for LetStatement
- [ ] Update Interpreter.execute() for AssignStatement
- [ ] Update Interpreter.evaluate() for Identifier
- [ ] Create tests/variables.spec.js with 15 tests
- [ ] All tests passing (122 total: 107 existing + 15 new)

## Notes for Future Releases

> **Stack Visualizer Reminder:** When implementing the stack visualizer (Release 8), remember to show variables currently in scope. This should display which variables are accessible at each point during execution.

> **AST Type Representation:** In a future release, represent variable types more explicitly in the AST visualization. This could show type information (number, string, boolean) alongside values to help Connor understand the type system.

## Status

**DRAFT** - Awaiting user approval
