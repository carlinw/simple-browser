# Release 8: Stack Visualization

> Follow CLAUDE.md - do not implement until user approves complete release plan.

## Code Quality Analysis (from Release 7)

**Current codebase:** 4,704 lines across 20 files (12 src, 7 tests, 1 css, 1 html)

### Source Files
| File | Lines | Status |
|------|-------|--------|
| scanner.js | 384 | OK - state machine is inherently complex |
| lexer.js | 370 | OK |
| parser.js | 334 | OK - clean recursive descent |
| main.js | 285 | OK - stable after refactoring |
| ast-renderer.js | 231 | OK |
| interpreter.js | 216 | OK - includes Environment class |
| examples.js | 189 | HAS ISSUE - modal code duplicated |
| reference.js | 138 | HAS ISSUE - modal code duplicated |
| parser-renderer.js | 136 | OK |
| visualizer.js | 101 | OK |
| output-renderer.js | 63 | OK |
| utils.js | 19 | OK |

### Test Files
| File | Lines | Tests | Coverage |
|------|-------|-------|----------|
| lexer-viz.spec.js | 368 | 24 | scanner.js, visualizer.js, reference.js, examples.js |
| parser.spec.js | 242 | 20 | parser.js |
| interpreter.spec.js | 219 | 22 | interpreter.js |
| ast.spec.js | 203 | 14 | ast-renderer.js |
| ui.spec.js | 166 | 15 | main.js, output-renderer.js |
| lexer.spec.js | 150 | 13 | lexer.js |
| variables.spec.js | 131 | 18 | interpreter.js (Environment) |

**Total: 126 tests passing**

---

### OOP & Encapsulation

**Classes (12 total):**
| Class | File | Responsibility | Encapsulation |
|-------|------|----------------|---------------|
| Lexer | lexer.js | Tokenize source code | ✅ Good - internal state hidden |
| Scanner | scanner.js | Step-by-step tokenization | ✅ Good |
| Parser | parser.js | Build AST from tokens | ✅ Good |
| Interpreter | interpreter.js | Execute AST | ✅ Good |
| Environment | interpreter.js | Variable storage | ✅ Good |
| ASTRenderer | ast-renderer.js | Render AST to DOM | ✅ Good |
| ParserRenderer | parser-renderer.js | Render tokens to DOM | ✅ Good |
| OutputRenderer | output-renderer.js | Render output/errors | ✅ Good |
| CodeVisualizer | visualizer.js | Highlight source code | ✅ Good |
| ReferencePanel | reference.js | Show language reference | ⚠️ Modal logic duplicated |
| ExamplesManager | examples.js | Manage example programs | ⚠️ Modal logic duplicated |
| RuntimeError | interpreter.js | Custom error type | ✅ Good |

**Assessment:** Good use of OOP. Each class has a single responsibility.

---

### Separation of Concerns

| Layer | Files | Status |
|-------|-------|--------|
| **Lexing** | lexer.js, scanner.js | ✅ Separate from parsing |
| **Parsing** | parser.js | ✅ Separate from interpretation |
| **Interpretation** | interpreter.js | ✅ Separate from rendering |
| **Rendering** | ast-renderer.js, parser-renderer.js, output-renderer.js | ✅ Each tab has own renderer |
| **UI/Orchestration** | main.js | ✅ Coordinates components |
| **Utilities** | utils.js | ✅ Shared character functions |
| **Modals** | reference.js, examples.js | ⚠️ Each manages own modal (duplicated) |

**Assessment:** Good separation. Main.js orchestrates, each module handles its domain.

---

### DRY (Don't Repeat Yourself)

**Issues Found:**

1. **Modal rendering duplicated** (SHOULD FIX)
   - `reference.js` and `examples.js` both implement:
     - Create overlay div
     - Create panel div
     - Handle click-outside-to-close
     - Close button handling
   - **Solution:** Extract `Modal` base class or utility

```javascript
// Duplicated pattern in both files:
this.overlay = document.createElement('div');
this.overlay.className = 'modal-overlay';
this.overlay.onclick = (e) => {
  if (e.target === this.overlay) this.close();
};
this.panel = document.createElement('div');
this.panel.className = 'modal-panel';
// ... render content ...
document.body.appendChild(this.overlay);
```

**Previously Fixed:**
- ✅ `isDigit`, `isAlpha`, `isAlphaNumeric` - extracted to utils.js (Release 6)
- ✅ Tab rendering - each tab has own renderer class (Release 7)

---

### Code Coverage

| Source File | Direct Tests | Indirect Tests | Coverage |
|-------------|--------------|----------------|----------|
| lexer.js | lexer.spec.js | - | ✅ High |
| scanner.js | lexer-viz.spec.js | - | ✅ High |
| parser.js | parser.spec.js | - | ✅ High |
| interpreter.js | interpreter.spec.js, variables.spec.js | - | ✅ High |
| ast-renderer.js | ast.spec.js | - | ✅ High |
| main.js | ui.spec.js | all specs | ✅ High |
| visualizer.js | lexer-viz.spec.js | - | ✅ Medium |
| parser-renderer.js | - | ui.spec.js, lexer-viz.spec.js | ⚠️ Indirect only |
| output-renderer.js | - | ui.spec.js, interpreter.spec.js | ⚠️ Indirect only |
| reference.js | lexer-viz.spec.js | - | ✅ Medium |
| examples.js | lexer-viz.spec.js | - | ✅ Medium |
| utils.js | - | lexer.spec.js, lexer-viz.spec.js | ⚠️ Indirect only |

**Assessment:** Good coverage overall. Renderers tested indirectly through integration tests.

---

### Issues to Address

| Priority | Issue | Action |
|----------|-------|--------|
| **SHOULD FIX** | Modal code duplicated in reference.js and examples.js | Extract Modal base class |
| **MONITOR** | CSS at 695 lines | Consider splitting if grows |
| **MONITOR** | parser-renderer.js, output-renderer.js have indirect coverage only | Consider unit tests if they grow complex |

---

### Code Quality Wins
- Good OOP with 12 well-encapsulated classes
- Clear separation of concerns (lexing → parsing → interpreting → rendering)
- Each tab has dedicated renderer class
- Environment class ready for visualization (has `getAll()` method)
- CharUtils extracted to eliminate duplicate code (Release 6)

---

## Goal

**Reorganize UI** from 2 sections to 3 sections, and add **Stack Visualization**.

This helps Connor understand the flow: **Code → Interpreter (internals) → Output**

## Features

### New 3-Section Layout

```
┌─────────────────┬─────────────────────────┬─────────────────┐
│                 │       Interpreter       │                 │
│      Code       │  [Parser] [AST] [Memory]│     Output      │
│                 │                         │                 │
│  (editor)       │  (tabs showing internal │  (program       │
│                 │   interpreter state)    │   output)       │
│                 │                         │                 │
└─────────────────┴─────────────────────────┴─────────────────┘
```

| Section | Purpose | Contents |
|---------|---------|----------|
| **Code** | Source code | Editor (input) |
| **Interpreter** | Internal state | Parser tab, AST tab, Memory tab |
| **Output** | Program results | Print output, errors |

### Memory Tab (New)

Shows variables currently in scope:

```
┌─────────────────────────┐
│ Memory                  │
├─────────────────────────┤
│ message  str  "Hello"   │
│ count    num  42        │
│ isReady  bool true      │
└─────────────────────────┘
```

### Type Indicators

Color-coded by type:
- Blue for numbers
- Green for strings
- Purple for booleans

### Real-time Updates

During animated execution (Run button):
- Memory tab updates as `let` statements execute
- Values update as assignments happen
- Changed values highlight briefly

## Implementation

### HTML Structure Change

```html
<main>
  <!-- Section 1: Code -->
  <section id="code-pane">
    <h2>Code</h2>
    <textarea id="code-editor">...</textarea>
  </section>

  <!-- Section 2: Interpreter (middle) -->
  <section id="interpreter-pane">
    <div class="pane-header">
      <h2>Interpreter</h2>
      <div class="interpreter-tabs">
        <button class="tab-btn" data-tab="parser">Parser</button>
        <button class="tab-btn" data-tab="ast">AST</button>
        <button class="tab-btn" data-tab="memory">Memory</button>
      </div>
    </div>
    <div class="tab-content">
      <div id="tab-parser" class="tab-panel">...</div>
      <div id="tab-ast" class="tab-panel">...</div>
      <div id="tab-memory" class="tab-panel">...</div>
    </div>
  </section>

  <!-- Section 3: Output -->
  <section id="output-pane">
    <h2>Output</h2>
    <pre id="output">...</pre>
  </section>
</main>
```

### CSS Layout

```css
main {
  display: grid;
  grid-template-columns: 1fr 1.5fr 1fr;  /* Code | Interpreter | Output */
  gap: 1rem;
}
```

### New Component: MemoryRenderer

```javascript
// src/memory-renderer.js
class MemoryRenderer {
  constructor(container) {
    this.container = container;
  }

  // Render current variable state
  render(environment) {
    const variables = environment.getAll();

    if (variables.length === 0) {
      this.container.innerHTML = '<div class="stack-empty">(no variables)</div>';
      return;
    }

    let html = '<div class="stack-list">';
    for (const [name, value] of variables) {
      const type = this.getType(value);
      const displayValue = this.formatValue(value);
      html += `
        <div class="stack-var">
          <span class="var-name">${name}</span>
          <span class="var-type">${type}</span>
          <span class="var-value var-${type}">${displayValue}</span>
        </div>
      `;
    }
    html += '</div>';
    this.container.innerHTML = html;
  }

  getType(value) {
    if (typeof value === 'number') return 'num';
    if (typeof value === 'string') return 'str';
    if (typeof value === 'boolean') return 'bool';
    return 'unknown';
  }

  formatValue(value) {
    if (typeof value === 'string') return `"${value}"`;
    return String(value);
  }

  // Highlight a variable that just changed
  highlightVariable(name) {
    const varEl = this.container.querySelector(`[data-name="${name}"]`);
    if (varEl) {
      varEl.classList.add('var-changed');
      setTimeout(() => varEl.classList.remove('var-changed'), 500);
    }
  }

  clear() {
    this.container.innerHTML = '';
  }
}
```

### Interpreter Hooks

Update interpreter to notify when variables change:

```javascript
class Interpreter {
  constructor(options = {}) {
    // ... existing options ...
    this.onVariableChange = options.onVariableChange || (() => {});
  }

  async execute(node) {
    // ...
    case 'LetStatement': {
      const value = await this.evaluate(node.value);
      this.environment.define(node.name, value);
      this.onVariableChange(node.name, value, 'define');
      result = value;
      break;
    }

    case 'AssignStatement': {
      const value = await this.evaluate(node.value);
      this.environment.assign(node.name, value);
      this.onVariableChange(node.name, value, 'assign');
      result = value;
      break;
    }
    // ...
  }
}
```

### Main.js Updates

```javascript
const memoryRenderer = new MemoryRenderer(tabMemory);

async function runAnimated() {
  // ...
  const interpreter = new Interpreter({
    stepDelay: 5000,
    onNodeEnter: (node) => astRenderer.highlightNode(node),
    onVariableChange: (name, value, action) => {
      memoryRenderer.render(interpreter.environment);
      memoryRenderer.highlightVariable(name);
    }
  });
  // ...
}
```

## File Changes

```
src/
  modal.js             # NEW - Extract Modal base class (DRY fix)
  memory-renderer.js   # NEW - Memory tab rendering
  interpreter.js       # Add onVariableChange callback
  main.js              # Add memoryRenderer, update tab handling
  reference.js         # Refactor to use Modal class
  examples.js          # Refactor to use Modal class
index.html             # Restructure to 3-section layout
styles/main.css        # 3-column grid, memory tab styles
tests/
  memory.spec.js       # NEW - Memory tab tests
```

## Playwright Tests

### UI Layout Tests

1. **"page has three sections"**
   - Verify Code, Interpreter, and Output panes exist

2. **"interpreter pane has three tabs"**
   - Verify Parser, AST, Memory tabs exist in Interpreter section

3. **"output pane shows program output"**
   - Run: `print 42`
   - Verify Output pane (not tab) shows `42`

### Memory Tab Tests

4. **"memory tab exists"**
   - Verify Memory tab button exists in Interpreter section

5. **"memory tab initially empty"**
   - Click Memory tab
   - Verify shows "(no variables)" or empty state

6. **"variables appear after let statement"**
   - Run: `let x = 42`
   - Verify Memory tab shows `x` with value `42`

7. **"multiple variables displayed"**
   - Run: `let a = 1\nlet b = 2\nlet c = 3`
   - Verify all three variables shown

8. **"variable values update on assignment"**
   - Run: `let x = 1\nx = 2`
   - Verify `x` shows value `2`

### Type Display Tests

9. **"number type displayed"**
   - Run: `let n = 42`
   - Verify type indicator shows "num"

10. **"string type displayed"**
    - Run: `let s = "hello"`
    - Verify type indicator shows "str"

11. **"boolean type displayed"**
    - Run: `let b = true`
    - Verify type indicator shows "bool"

12. **"type changes when variable reassigned"**
    - Run: `let x = 42\nx = "hello"`
    - Verify type changes from "num" to "str"

### Integration Tests

13. **"memory panel updates during animated run"**
    - Use Run (animated) with a program that has multiple variables
    - Verify panel updates as each `let` executes

14. **"memory cleared on reset"**
    - Run a program, then click Reset
    - Verify Memory tab is cleared

15. **"memory panel works with Run Fast"**
    - Click Run Fast
    - Verify final variable state is shown

## Deliverables

### Code Quality Fix (from analysis)
- [ ] Create src/modal.js - Extract Modal base class
- [ ] Refactor reference.js to use Modal class
- [ ] Refactor examples.js to use Modal class

### UI Restructure (3-section layout)
- [ ] Update index.html - 3 sections: Code, Interpreter, Output
- [ ] Move tabs (Parser, AST) to Interpreter section
- [ ] Create Output section (no tabs, just output)
- [ ] Update styles/main.css - 3-column grid layout
- [ ] Update main.js - handle new DOM structure

### Memory Tab Feature
- [ ] Create src/memory-renderer.js
- [ ] Add Memory tab to Interpreter section
- [ ] Add onVariableChange callback to interpreter.js
- [ ] Connect memoryRenderer to interpreter in main.js
- [ ] Add CSS styles for memory display (type colors)

### Tests
- [ ] Update existing tests for new UI structure
- [ ] Create tests/memory.spec.js with 15 tests
- [ ] All tests passing (141+ total)

## Notes for Future Releases

> **Stack Frames:** When functions are added (Release 13-14), the stack visualization will need to show multiple frames/scopes, not just global variables.

> **AST Type Representation:** In a future release, represent variable types more explicitly in the AST visualization.

## Status

**DRAFT** - Awaiting user approval
