# Release 13: Arrays

> Follow CLAUDE.md - do not implement until user approves complete release plan.

## Code Quality Analysis

**Current codebase:** ~6,300 lines across 32 files (16 src, 15 tests, 3 css, 1 html)
**Tests:** 185 passing â†’ 204 passing

### File Size Review

| File | Lines | Status |
|------|-------|--------|
| interpreter.css | 630 | **NEEDS SPLIT** - exceeds 600 threshold |
| parser.js | 459 | OK |
| lexer.js | 390 | OK |
| scanner.js | 384 | OK |
| main.js | 369 | OK |
| ast-renderer.js | 314 | OK |
| interpreter.js | 267 | OK |
| memory-renderer.js | 187 | OK |

### Issues to Address

| Priority | Issue | Action |
|----------|-------|--------|
| **HIGH** | interpreter.css at 630 lines | Split into component files |
| **NONE** | All other files healthy | Continue as-is |

---

## Goals

### 1. Arrays (from roadmap Phase 4)

Add arrays to the language:
- Array literals: `[1, 2, 3]`
- Index access: `arr[0]`
- Index assignment: `arr[0] = 5`
- Length function: `len(arr)`

This enables Connor to understand:
- Sequential data storage
- Zero-based indexing
- Array mutation

### 2. CSS Refactoring

Split interpreter.css into logical components to stay under 600 lines per file.

### 3. Parser Tab Enhancements

Improve the Parser tab token display:
- Add total token count at the top
- Add Token column (leftmost) showing sequential token numbers (1, 2, 3...)

---

## Language Syntax (this release)

### Array Literal

```
let numbers = [1, 2, 3, 4, 5]
let empty = []
let mixed = [1, "hello", true]
```

### Index Access

```
let first = numbers[0]
let last = numbers[4]
```

### Index Assignment

```
numbers[0] = 10
```

### Built-in Length Function

```
let size = len(numbers)
print len([1, 2, 3])  // 3
```

### Examples

```
// Sum array elements
let nums = [1, 2, 3, 4, 5]
let sum = 0
let i = 0
while (i < len(nums)) {
  sum = sum + nums[i]
  i = i + 1
}
print sum  // 15

// Reverse array in-place
let arr = [1, 2, 3, 4]
let left = 0
let right = len(arr) - 1
while (left < right) {
  let temp = arr[left]
  arr[left] = arr[right]
  arr[right] = temp
  left = left + 1
  right = right - 1
}
print arr  // [4, 3, 2, 1]
```

---

## Implementation

### Lexer Changes

Add `[` and `]` to PUNCTUATION:

```javascript
const PUNCTUATION = new Set(['(', ')', '{', '}', ',', '[', ']']);
```

### Parser Changes

#### 1. Parse Array Literal

In `parsePrimary()`:

```javascript
if (this.match('PUNCTUATION', '[')) {
  return this.parseArrayLiteral();
}
```

```javascript
parseArrayLiteral() {
  const startToken = this.previous();
  const elements = [];

  if (!this.check('PUNCTUATION', ']')) {
    do {
      elements.push(this.parseExpression());
    } while (this.match('PUNCTUATION', ','));
  }

  const endToken = this.consume('PUNCTUATION', ']', "Expected ']' after array elements");

  return {
    type: 'ArrayLiteral',
    elements: elements,
    token: startToken,
    endToken: endToken
  };
}
```

#### 2. Parse Index Access and Assignment

After parsing primary, check for `[`:

```javascript
// In parsePrimary, after getting a value
let expr = /* parsed primary */;

// Handle index access (can chain: arr[0][1])
while (this.check('PUNCTUATION', '[')) {
  expr = this.parseIndexExpression(expr);
}

return expr;
```

```javascript
parseIndexExpression(object) {
  const startToken = this.advance(); // consume '['
  const index = this.parseExpression();
  const endToken = this.consume('PUNCTUATION', ']', "Expected ']' after index");

  return {
    type: 'IndexExpression',
    object: object,
    index: index,
    token: startToken,
    endToken: endToken
  };
}
```

#### 3. Parse Index Assignment

In `parseStatement()`, check for `identifier[expr] = value`:

```javascript
// Check for index assignment: arr[i] = value
if (this.check('IDENTIFIER')) {
  const identToken = this.peek();
  const nextToken = this.peekNext();

  if (nextToken && nextToken.type === 'PUNCTUATION' && nextToken.value === '[') {
    // This might be index assignment or just index access
    // Parse the expression first, then check for '='
    const expr = this.parseExpression();

    if (expr.type === 'IndexExpression' && this.match('OPERATOR', '=')) {
      const value = this.parseExpression();
      return {
        type: 'IndexAssignStatement',
        object: expr.object,
        index: expr.index,
        value: value,
        token: identToken,
        endToken: this.previous()
      };
    }

    // Not an assignment, wrap as expression statement
    return { type: 'ExpressionStatement', expression: expr, token: expr.token };
  }
}
```

#### 4. Parse len() Built-in

Handle `len` as a built-in function call:

```javascript
// In parseCallExpression or parsePrimary
if (nameToken.value === 'len') {
  return this.parseBuiltinCall(nameToken);
}
```

```javascript
parseBuiltinCall(nameToken) {
  this.consume('PUNCTUATION', '(', "Expected '(' after built-in function");
  const arg = this.parseExpression();
  const endToken = this.consume('PUNCTUATION', ')', "Expected ')' after argument");

  return {
    type: 'BuiltinCall',
    name: nameToken.value,
    argument: arg,
    token: nameToken,
    endToken: endToken
  };
}
```

### Interpreter Changes

#### 1. Evaluate Array Literal

```javascript
case 'ArrayLiteral': {
  const elements = [];
  for (const elem of node.elements) {
    elements.push(await this.evaluate(elem));
  }
  result = elements;
  break;
}
```

#### 2. Evaluate Index Expression

```javascript
case 'IndexExpression': {
  const object = await this.evaluate(node.object);
  const index = await this.evaluate(node.index);

  if (!Array.isArray(object)) {
    throw new RuntimeError('Cannot index non-array value');
  }
  if (typeof index !== 'number' || !Number.isInteger(index)) {
    throw new RuntimeError('Array index must be an integer');
  }
  if (index < 0 || index >= object.length) {
    throw new RuntimeError(`Array index ${index} out of bounds (length: ${object.length})`);
  }

  result = object[index];
  break;
}
```

#### 3. Execute Index Assignment

```javascript
case 'IndexAssignStatement': {
  const object = await this.evaluate(node.object);
  const index = await this.evaluate(node.index);
  const value = await this.evaluate(node.value);

  if (!Array.isArray(object)) {
    throw new RuntimeError('Cannot index non-array value');
  }
  if (typeof index !== 'number' || !Number.isInteger(index)) {
    throw new RuntimeError('Array index must be an integer');
  }
  if (index < 0 || index >= object.length) {
    throw new RuntimeError(`Array index ${index} out of bounds (length: ${object.length})`);
  }

  object[index] = value;
  // Trigger variable change callback for visualization
  this.onVariableChange(null, object, 'update');
  break;
}
```

#### 4. Evaluate Built-in Call (len)

```javascript
case 'BuiltinCall': {
  const arg = await this.evaluate(node.argument);

  switch (node.name) {
    case 'len':
      if (Array.isArray(arg)) {
        result = arg.length;
      } else if (typeof arg === 'string') {
        result = arg.length;
      } else {
        throw new RuntimeError('len() requires an array or string');
      }
      break;
    default:
      throw new RuntimeError(`Unknown built-in function: ${node.name}`);
  }
  break;
}
```

### AST Renderer Changes

Add rendering for new node types:
- ArrayLiteral: `[elements]`
- IndexExpression: `object[index]`
- IndexAssignStatement: `object[index] = value`
- BuiltinCall: `len(arg)`

### Memory Renderer Changes

Update variable display to show arrays properly:
- Show as `[1, 2, 3]` format
- Add array type indicator
- Highlight individual elements on change

```javascript
// Format value for display
formatValue(value) {
  if (Array.isArray(value)) {
    return '[' + value.map(v => this.formatValue(v)).join(', ') + ']';
  }
  // ... existing formatting
}
```

### Reference Panel Changes (src/reference.js)

Add new "Arrays" section and "Built-ins" section:

```javascript
getContent() {
  return {
    keywords: [ /* existing */ ],
    operators: [ /* existing */ ],
    variables: [ /* existing */ ],
    arrays: [
      { name: 'Literal', desc: '[1, 2, 3]' },
      { name: 'Access', desc: 'arr[0]' },
      { name: 'Assignment', desc: 'arr[0] = value' },
      { name: 'Nested', desc: 'arr[0][1]' },
    ],
    builtins: [
      { name: 'len(x)', desc: 'length of array or string' },
    ]
  };
}

getBodyContent() {
  // ... existing sections ...
  // Add:
  <section>
    <h3>Arrays</h3>
    <dl class="ref-list">
      ${content.arrays.map(a => `<dt>${a.name}</dt><dd>${a.desc}</dd>`).join('')}
    </dl>
  </section>
  <section>
    <h3>Built-in Functions</h3>
    <dl class="ref-list">
      ${content.builtins.map(b => `<dt>${b.name}</dt><dd>${b.desc}</dd>`).join('')}
    </dl>
  </section>
}
```

---

## CSS Refactoring

### Current interpreter.css Structure (630 lines)

| Lines | Section | Destination |
|-------|---------|-------------|
| 1-82 | Code Editor & Code Display | interpreter.css (keep) |
| 84-168 | Output Header, Tabs, Output | interpreter.css (keep) |
| 170-228 | Scanner state & Token display | interpreter.css (keep) |
| 230-429 | **AST Tree** (~200 lines) | **ast.css (move)** |
| 431-630 | **Memory/Stack** (~200 lines) | **memory.css (move)** |

### File Structure After Split

```
styles/
  base.css           # 187 lines (unchanged)
  interpreter.css    # ~228 lines (reduced from 630)
  ast.css            # ~200 lines (NEW - lines 230-429)
  memory.css         # ~200 lines (NEW - lines 431-630)
  modals.css         # 149 lines (unchanged)
```

### ast.css Contents (lines 230-429)

```css
/* AST Tree - Graphical Style */
.ast-tree { ... }
#tab-ast { ... }
#tab-ast:focus { ... }
#tab-ast:focus-visible { ... }

/* Node container - handles vertical layout */
.ast-node-container { ... }
.ast-node { ... }
.ast-node strong { ... }
.ast-node em { ... }
.ast-has-children { ... }
.ast-has-children:hover { ... }

/* Node type colors */
.ast-program { ... }
.ast-letstatement { ... }
.ast-assignstatement { ... }
.ast-printstatement { ... }
.ast-expressionstatement { ... }
.ast-ifstatement { ... }
.ast-whilestatement { ... }
.ast-block { ... }
.ast-binaryexpression { ... }
.ast-identifier { ... }
.ast-numberliteral { ... }
.ast-stringliteral { ... }
.ast-booleanliteral { ... }

/* Connector lines */
.ast-connector { ... }
.ast-children { ... }
.ast-children::before { ... }
.ast-children:has(.ast-child:only-child)::before { ... }
.ast-child { ... }
.ast-child::before { ... }
.ast-edge-label { ... }

/* Collapse/expand */
.ast-collapsed > .ast-connector { ... }
.ast-collapsed > .ast-node::after { ... }

/* Execution visualization */
.ast-executing { ... }
@keyframes ast-pulse { ... }

/* Color Key/Legend for AST */
.ast-legend { ... }
.ast-legend-item { ... }
.ast-legend-color { ... }
.ast-legend-color.legend-* { ... }
.ast-legend-label { ... }
```

### memory.css Contents (lines 431-630)

```css
/* Memory/Stack display */
.memory-empty { ... }

/* Memory legend */
.memory-legend { ... }
.memory-legend-item { ... }
.memory-legend-color { ... }
.memory-legend-color.legend-num { ... }
.memory-legend-color.legend-str { ... }
.memory-legend-color.legend-bool { ... }
.memory-legend-color.legend-func { ... }
.memory-legend-label { ... }

/* Variable list */
.memory-list { ... }
.memory-var { ... }
.var-name { ... }
.var-type { ... }
.var-type-num { ... }
.var-type-str { ... }
.var-type-bool { ... }
.var-type-func { ... }
.var-value { ... }
.var-value-num { ... }
.var-value-str { ... }
.var-value-bool { ... }
.var-value-func { ... }
.var-changed { ... }
@keyframes var-highlight { ... }

/* Call Stack Display */
.call-stack { ... }
.call-stack-label { ... }
.stack-frame { ... }
.stack-frame-active { ... }
.stack-frame-global { ... }
.stack-frame-global.stack-frame-active { ... }
.frame-header { ... }
.stack-frame-active .frame-header { ... }
.stack-frame-global .frame-header { ... }
.frame-variables { ... }
.frame-variables .memory-var { ... }
.frame-variables .memory-var:last-child { ... }
.memory-empty-frame { ... }
```

### interpreter.css Remaining (lines 1-228)

```css
/* Code Editor */
#code-editor { ... }
#code-editor:focus { ... }
#code-editor:disabled { ... }

/* Code Display (for step-through highlighting) */
.code-display { ... }
.code-display .code-before, .code-after { ... }
.code-display .code-current { ... }
.code-display .code-done { ... }
.code-display .code-buffer { ... }
.code-display .code-cursor { ... }
.code-display .code-pending { ... }
.code-display .code-executing { ... }
@keyframes code-pulse { ... }

/* Output Header */
.output-header { ... }
.output-header h2 { ... }

/* Output Tabs */
.output-tabs { ... }
.tab-btn { ... }
.tab-btn:hover { ... }
.tab-btn.active { ... }
.tab-content { ... }
.tab-panel { ... }
.tab-panel.active { ... }

/* Output */
#output { ... }

/* Scanner state display */
.scan-section { ... }
.scan-header { ... }
.scan-line { ... }
.scan-label { ... }
.scan-action { ... }

/* Token display */
.tokens-section { ... }
.tokens-header { ... }
.token-line { ... }
.token-empty { ... }
.token-new { ... }
.token-skipped { ... }
.token-eof { ... }
```

---

## Tests

### Array Tests (tests/arrays.spec.js)

1. **"array literal creates array"**
   - Run: `let arr = [1, 2, 3]\nprint len(arr)`
   - Output: `3`

2. **"empty array"**
   - Run: `let arr = []\nprint len(arr)`
   - Output: `0`

3. **"array index access"**
   - Run: `let arr = [10, 20, 30]\nprint arr[1]`
   - Output: `20`

4. **"array first element (zero-based)"**
   - Run: `let arr = [5, 10, 15]\nprint arr[0]`
   - Output: `5`

5. **"array last element"**
   - Run: `let arr = [1, 2, 3]\nprint arr[len(arr) - 1]`
   - Output: `3`

6. **"array index assignment"**
   - Run: `let arr = [1, 2, 3]\narr[1] = 99\nprint arr[1]`
   - Output: `99`

7. **"array mutation persists"**
   - Run: `let arr = [1, 2]\narr[0] = 5\narr[1] = 10\nprint arr[0] + arr[1]`
   - Output: `15`

8. **"array with expressions"**
   - Run: `let x = 5\nlet arr = [x, x + 1, x * 2]\nprint arr[2]`
   - Output: `10`

9. **"nested array access"**
   - Run: `let arr = [[1, 2], [3, 4]]\nprint arr[1][0]`
   - Output: `3`

10. **"len works on strings"**
    - Run: `print len("hello")`
    - Output: `5`

11. **"array in loop"**
    - Run: `let arr = [1, 2, 3]\nlet sum = 0\nlet i = 0\nwhile (i < len(arr)) { sum = sum + arr[i]\ni = i + 1 }\nprint sum`
    - Output: `6`

12. **"array passed to function"**
    - Run: `function first(arr) { return arr[0] }\nprint first([42, 1, 2])`
    - Output: `42`

### Negative Tests

13. **"index out of bounds (high)"**
    - Run: `let arr = [1, 2, 3]\nprint arr[5]`
    - Error: `out of bounds`

14. **"index out of bounds (negative)"**
    - Run: `let arr = [1, 2, 3]\nprint arr[-1]`
    - Error: `out of bounds`

15. **"index non-integer"**
    - Run: `let arr = [1, 2, 3]\nprint arr[1.5]`
    - Error: `must be an integer`

16. **"index non-array"**
    - Run: `let x = 5\nprint x[0]`
    - Error: `Cannot index non-array`

17. **"len on non-array/string"**
    - Run: `print len(42)`
    - Error: `requires an array or string`

---

## File Changes

```
src/
  lexer.js           # Add '[', ']' to PUNCTUATION
  parser.js          # Add parseArrayLiteral, parseIndexExpression,
                     #   parseIndexAssignment, parseBuiltinCall
  interpreter.js     # Add ArrayLiteral, IndexExpression,
                     #   IndexAssignStatement, BuiltinCall
  ast-renderer.js    # Add rendering for new node types
  memory-renderer.js # Update formatValue for arrays
  reference.js       # Add Arrays and Built-ins sections
  parser-renderer.js # Add token count and token number column
styles/
  interpreter.css    # Reduced - AST/memory styles moved out
  ast.css            # NEW - AST visualization styles
  memory.css         # NEW - Memory visualization styles
tests/
  arrays.spec.js     # NEW - 17 tests for arrays
  ui.spec.js         # Add 2 tests for token count/numbers
index.html           # Add new CSS files
```

---

## Deliverables

### Arrays
- [ ] Lexer: Add `[`, `]` to PUNCTUATION
- [ ] Parser: parseArrayLiteral()
- [ ] Parser: parseIndexExpression()
- [ ] Parser: parseIndexAssignment() or IndexAssignStatement
- [ ] Parser: parseBuiltinCall() for len()
- [ ] Interpreter: ArrayLiteral evaluation
- [ ] Interpreter: IndexExpression evaluation
- [ ] Interpreter: IndexAssignStatement execution
- [ ] Interpreter: BuiltinCall (len) evaluation
- [ ] AST Renderer: New node types
- [ ] Memory Renderer: Array formatting
- [ ] Reference Panel: Add Arrays and Built-ins sections

### CSS Refactoring
- [ ] Create styles/ast.css with AST styles (lines 230-429)
- [ ] Create styles/memory.css with memory/stack styles (lines 431-630)
- [ ] Update styles/interpreter.css (keep lines 1-228)
- [ ] Update index.html to include new CSS files

### Parser Tab Enhancements
- [ ] Add token count to renderTokens() in parser-renderer.js
- [ ] Add Token column with sequential numbers (1, 2, 3...)
- [ ] Update column headers to include Token

### Tests
- [ ] Create tests/arrays.spec.js with 17 tests
- [ ] Add 2 UI tests for parser tab enhancements
- [ ] All tests passing (204 total)

---

## Example Program

Add to examples for demonstrating arrays:

```javascript
// Arrays example
window.EXAMPLES['arrays'] = {
  name: 'Arrays',
  description: 'Array creation and manipulation',
  code: `// Create an array
let numbers = [10, 20, 30, 40, 50]

// Access elements (zero-based index)
print numbers[0]
print numbers[2]

// Modify elements
numbers[1] = 25
print numbers[1]

// Get array length
print len(numbers)

// Loop through array
let i = 0
let sum = 0
while (i < len(numbers)) {
  sum = sum + numbers[i]
  i = i + 1
}
print "Sum: " + sum`
};
```

---

## Notes

**Why arrays matter:**
- First compound data structure
- Introduces zero-based indexing (universal in programming)
- Shows difference between value types (numbers) and reference types (arrays)
- Enables algorithms like sorting, searching

**Design decisions:**
- Zero-based indexing (like JavaScript, C, Python)
- Bounds checking (throws error on out-of-bounds)
- Arrays are mutable (can change elements)
- `len()` as built-in function (not method) - simpler for beginners
- Mixed types allowed (like JavaScript/Python)

**Future enhancements (not this release):**
- Array methods: push, pop, slice
- For-each loops
- Array spread syntax

---

## Status

**COMPLETE** - 204 tests passing

### Completed Deliverables

**Parser Tab Enhancements:**
- [x] Add token count display (`Tokens: N`)
- [x] Add Token column (leftmost) with sequential token numbers
- [x] Update column headers: Token, Line, Col, Type, Value
- [x] Tests: 2 new UI tests (token count, token numbers)

**Arrays:**
- [x] Lexer: Add `[`, `]` to PUNCTUATION
- [x] Parser: parseArrayLiteral()
- [x] Parser: parseIndexExpression() via parsePostfix()
- [x] Parser: IndexAssignStatement handling in parseStatement()
- [x] Parser: parseBuiltinCall() for len()
- [x] Interpreter: ArrayLiteral evaluation
- [x] Interpreter: IndexExpression evaluation
- [x] Interpreter: IndexAssignStatement execution
- [x] Interpreter: BuiltinCall (len) evaluation
- [x] AST Renderer: New node types (ArrayLiteral, IndexExpression, IndexAssignStatement, BuiltinCall)
- [x] AST Renderer: Legend items for Array and Built-in
- [x] Memory Renderer: Array type and formatting
- [x] Memory Renderer: Legend item for Array
- [x] Reference Panel: Arrays section
- [x] Reference Panel: Built-in Functions section

**CSS Refactoring:**
- [x] Create styles/ast.css (200 lines - AST visualization)
- [x] Create styles/memory.css (200 lines - Memory/stack visualization)
- [x] Update styles/interpreter.css (228 lines - reduced from 630)
- [x] Update index.html to include new CSS files

**Tests:**
- [x] Create tests/arrays.spec.js with 17 tests
- [x] Add 2 UI tests for parser tab enhancements (token count, token numbers)
- [x] All tests passing (204 total, +19 from Release 12)

**Example:**
- [x] Create src/examples/arrays.js
- [x] Add to index.html
