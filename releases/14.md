# Release 14: Logical Operators & Modulo

> Follow CLAUDE.md - do not implement until user approves complete release plan.

## Code Quality Analysis

**Current codebase:** ~3,300 src lines, ~2,400 test lines across 33 files
**Tests:** 204 passing

### File Size Review

| File | Lines | Status |
|------|-------|--------|
| parser.js | 548 | OK (largest, monitor) |
| lexer.js | 390 | OK |
| scanner.js | 384 | OK |
| main.js | 369 | OK |
| ast-renderer.js | 363 | OK |
| interpreter.js | 332 | OK |

### CSS Files (all healthy after Release 13 split)

| File | Lines | Status |
|------|-------|--------|
| interpreter.css | 228 | OK |
| memory.css | 209 | OK |
| ast.css | 208 | OK |
| base.css | 187 | OK |
| modals.css | 149 | OK |

### DRY Issues to Address

| Priority | Issue | Action |
|----------|-------|--------|
| **MEDIUM** | BinaryExpression creation repeated 4x in parser.js | Extract `makeBinaryExpr()` helper |
| **MEDIUM** | Array bounds validation repeated 2x in interpreter.js | Extract `validateArrayAccess()` helper |

---

## Goals

Add fundamental operators that are currently missing from the language, plus DRY refactoring.

### 1. Logical Operators (using keywords, not symbols)

- `and` - returns true if both operands are truthy
- `or` - returns true if either operand is truthy
- `not` - unary negation, returns opposite truthiness

Using keywords instead of `&&`/`||`/`!` makes code more readable for beginners:
```
if (x > 0 and x < 10) { ... }
if (isEmpty or hasError) { ... }
if (not found) { ... }
```

### 2. Modulo Operator

- `%` - returns remainder after division

Enables:
```
if (n % 2 == 0) { print "even" }
let lastDigit = n % 10
```

### 3. Unary Minus

- `-expr` - negates a numeric value

Currently must write `0 - 5` to get `-5`. This enables:
```
let negative = -5
let opposite = -x
```

### 4. DRY Refactoring

Extract repeated code patterns:
- `makeBinaryExpr()` helper in parser.js (removes 4x duplication)
- `validateArrayAccess()` helper in interpreter.js (removes 2x duplication)

---

## Language Syntax (this release)

### Logical AND (and)

```
let a = true and true    // true
let b = true and false   // false
let c = 5 > 0 and 5 < 10 // true
```

**Short-circuit evaluation:** If left side is falsy, right side is not evaluated.

### Logical OR (or)

```
let a = false or true   // true
let b = false or false  // false
let c = x == 0 or y == 0 // true if either is 0
```

**Short-circuit evaluation:** If left side is truthy, right side is not evaluated.

### Logical NOT (not)

```
let a = not true        // false
let b = not false       // true
let c = not (x > 5)     // true if x <= 5
```

### Modulo (%)

```
let remainder = 10 % 3  // 1
let isEven = n % 2 == 0
let lastDigit = 123 % 10 // 3
```

### Unary Minus (-)

```
let x = -5
let y = -x              // negates x
let z = -(a + b)        // negates expression
```

---

## Implementation

### Lexer Changes

Add `%` to OPERATORS:

```javascript
const OPERATORS = {
  '+': '+',
  '-': '-',
  '*': '*',
  '/': '/',
  '%': '%',        // NEW
  '=': '=',
  '==': '==',
  '!=': '!=',
  '<': '<',
  '>': '>',
  '<=': '<=',
  '>=': '>=',
};
```

Add `and`, `or`, `not` to KEYWORDS:

```javascript
const KEYWORDS = new Set([
  'let', 'if', 'else', 'while', 'function',
  'return', 'true', 'false', 'print', 'stop',
  'and', 'or', 'not'  // NEW
]);
```

### Parser Changes

#### 1. DRY Helper: makeBinaryExpr()

Extract repeated BinaryExpression creation:

```javascript
makeBinaryExpr(left, operatorToken, right) {
  return {
    type: 'BinaryExpression',
    operator: operatorToken.value,
    left: left,
    right: right,
    token: left.token,
    endToken: right.endToken || right.token
  };
}
```

#### 2. Operator Precedence

Update precedence to include new operators:

| Precedence | Operators | Associativity |
|------------|-----------|---------------|
| 1 (lowest) | `or` | Left |
| 2 | `and` | Left |
| 3 | `== !=` | Left |
| 4 | `< > <= >=` | Left |
| 5 | `+ -` | Left |
| 6 | `* / %` | Left |
| 7 (highest) | `not -` (unary) | Right |

#### 3. Parse Logical OR (lowest precedence for binary)

```javascript
parseExpression() {
  return this.parseOr();
}

parseOr() {
  let left = this.parseAnd();

  while (this.match('KEYWORD', 'or')) {
    const operator = this.previous();
    const right = this.parseAnd();
    left = this.makeBinaryExpr(left, operator, right);
  }

  return left;
}
```

#### 4. Parse Logical AND

```javascript
parseAnd() {
  let left = this.parseEquality();

  while (this.match('KEYWORD', 'and')) {
    const operator = this.previous();
    const right = this.parseEquality();
    left = this.makeBinaryExpr(left, operator, right);
  }

  return left;
}
```

#### 5. Update Multiplication to Include Modulo

```javascript
parseFactor() {
  let left = this.parseUnary();

  while (this.check('OPERATOR') &&
         ['*', '/', '%'].includes(this.peek().value)) {
    const operator = this.advance();
    const right = this.parseUnary();
    left = this.makeBinaryExpr(left, operator, right);
  }

  return left;
}
```

#### 6. Parse Unary (not and -)

```javascript
parseUnary() {
  // Handle 'not' keyword
  if (this.match('KEYWORD', 'not')) {
    const operator = this.previous();
    const operand = this.parseUnary(); // Right associative
    return {
      type: 'UnaryExpression',
      operator: 'not',
      operand: operand,
      token: operator,
      endToken: operand.endToken || operand.token
    };
  }

  // Handle unary minus
  if (this.check('OPERATOR', '-')) {
    const operator = this.advance();
    const operand = this.parseUnary(); // Right associative
    return {
      type: 'UnaryExpression',
      operator: '-',
      operand: operand,
      token: operator,
      endToken: operand.endToken || operand.token
    };
  }

  return this.parsePostfix();
}
```

#### 7. Refactor Existing Precedence Methods

Update parseEquality, parseComparison, parseTerm to use `makeBinaryExpr()`:

```javascript
parseEquality() {
  let left = this.parseComparison();

  while (this.check('OPERATOR', '==') || this.check('OPERATOR', '!=')) {
    const operator = this.advance();
    const right = this.parseComparison();
    left = this.makeBinaryExpr(left, operator, right);
  }

  return left;
}
// Similar updates for parseComparison, parseTerm
```

### Interpreter Changes

#### 1. DRY Helper: validateArrayAccess()

Extract repeated array validation:

```javascript
validateArrayAccess(object, index) {
  if (!Array.isArray(object)) {
    throw new RuntimeError('Cannot index non-array value');
  }
  if (typeof index !== 'number' || !Number.isInteger(index)) {
    throw new RuntimeError('Array index must be an integer');
  }
  if (index < 0 || index >= object.length) {
    throw new RuntimeError(`Array index ${index} out of bounds (length: ${object.length})`);
  }
}
```

Then use in IndexExpression and IndexAssignStatement:

```javascript
case 'IndexExpression': {
  const object = await this.evaluate(node.object);
  const index = await this.evaluate(node.index);
  this.validateArrayAccess(object, index);
  result = object[index];
  break;
}
```

#### 2. Evaluate Unary Expression

```javascript
case 'UnaryExpression': {
  const operand = await this.evaluate(node.operand);

  switch (node.operator) {
    case 'not':
      result = !this.isTruthy(operand);
      break;
    case '-':
      if (typeof operand !== 'number') {
        throw new RuntimeError('Unary minus requires a number');
      }
      result = -operand;
      break;
  }
  break;
}
```

#### 3. Update Binary Expression for Logical Operators

```javascript
case 'BinaryExpression': {
  // Short-circuit evaluation for 'and' and 'or'
  if (node.operator === 'and') {
    const left = await this.evaluate(node.left);
    if (!this.isTruthy(left)) {
      result = left; // Short-circuit: return falsy value
    } else {
      result = await this.evaluate(node.right);
    }
    break;
  }

  if (node.operator === 'or') {
    const left = await this.evaluate(node.left);
    if (this.isTruthy(left)) {
      result = left; // Short-circuit: return truthy value
    } else {
      result = await this.evaluate(node.right);
    }
    break;
  }

  // Evaluate both operands for other operators
  const left = await this.evaluate(node.left);
  const right = await this.evaluate(node.right);

  switch (node.operator) {
    // ... existing cases ...
    case '%':
      if (typeof left !== 'number' || typeof right !== 'number') {
        throw new RuntimeError('Modulo requires numbers');
      }
      if (right === 0) {
        throw new RuntimeError('Modulo by zero');
      }
      result = left % right;
      break;
  }
  break;
}
```

### AST Renderer Changes

Add UnaryExpression node type:

```javascript
getNodeLabel(node) {
  switch (node.type) {
    // ... existing cases ...
    case 'UnaryExpression':
      return node.operator;
  }
}

getChildren(node) {
  switch (node.type) {
    // ... existing cases ...
    case 'UnaryExpression':
      return [{ label: 'operand', node: node.operand }];
  }
}
```

Add legend item for Unary:

```javascript
{ type: 'unaryexpression', label: 'Unary', color: '#ffcc80' }
```

### Reference Panel Changes

Update keywords and operators sections:

```javascript
keywords: [
  // ... existing ...
  { name: 'and', desc: 'logical and' },
  { name: 'or', desc: 'logical or' },
  { name: 'not', desc: 'logical not' },
],
operators: [
  { name: '+ - * / %', desc: 'arithmetic' },
  { name: '=', desc: 'assignment' },
  { name: '== !=', desc: 'equality' },
  { name: '< > <= >=', desc: 'comparison' },
  { name: '-x', desc: 'negation' },
],
```

---

## Tests

### tests/operators.spec.js (NEW)

#### Logical AND Tests

1. **"true and true returns true"**
   - Run: `print true and true`
   - Output: `true`

2. **"true and false returns false"**
   - Run: `print true and false`
   - Output: `false`

3. **"false and true returns false"**
   - Run: `print false and true`
   - Output: `false`

4. **"and with comparison expressions"**
   - Run: `let x = 5\nprint x > 0 and x < 10`
   - Output: `true`

5. **"and short-circuits on false"**
   - Run: `let x = 0\nif (false and (x = 1)) { }\nprint x`
   - Output: `0` (assignment not executed)

#### Logical OR Tests

6. **"false or true returns true"**
   - Run: `print false or true`
   - Output: `true`

7. **"false or false returns false"**
   - Run: `print false or false`
   - Output: `false`

8. **"or with comparison expressions"**
   - Run: `let x = 15\nprint x < 0 or x > 10`
   - Output: `true`

9. **"or short-circuits on true"**
   - Run: `let x = 0\nif (true or (x = 1)) { }\nprint x`
   - Output: `0` (assignment not executed)

#### Logical NOT Tests

10. **"not true returns false"**
    - Run: `print not true`
    - Output: `false`

11. **"not false returns true"**
    - Run: `print not false`
    - Output: `true`

12. **"not with comparison"**
    - Run: `let x = 5\nprint not (x > 10)`
    - Output: `true`

13. **"double negation"**
    - Run: `print not not true`
    - Output: `true`

#### Modulo Tests

14. **"10 % 3 returns 1"**
    - Run: `print 10 % 3`
    - Output: `1`

15. **"even number check"**
    - Run: `let n = 4\nprint n % 2 == 0`
    - Output: `true`

16. **"odd number check"**
    - Run: `let n = 7\nprint n % 2 == 1`
    - Output: `true`

17. **"modulo by zero error"**
    - Run: `print 5 % 0`
    - Error: `Modulo by zero`

#### Unary Minus Tests

18. **"negative literal"**
    - Run: `print -5`
    - Output: `-5`

19. **"negate variable"**
    - Run: `let x = 10\nprint -x`
    - Output: `-10`

20. **"negate expression"**
    - Run: `print -(3 + 2)`
    - Output: `-5`

21. **"double negative"**
    - Run: `let x = 5\nprint --x`
    - Output: `5`

22. **"unary minus on non-number error"**
    - Run: `print -"hello"`
    - Error: `requires a number`

#### Precedence Tests

23. **"and has higher precedence than or"**
    - Run: `print true or false and false`
    - Output: `true` (parsed as `true or (false and false)`)

24. **"not has highest precedence"**
    - Run: `print not false and true`
    - Output: `true`

25. **"% same precedence as * /"**
    - Run: `print 10 + 6 % 4`
    - Output: `12` (parsed as `10 + (6 % 4)`)

---

## File Changes

```
src/
  lexer.js           # Add &&, ||, !, % to OPERATORS
  parser.js          # Add parseOr, parseAnd, parseUnary, update parseMultiplication
  interpreter.js     # Add UnaryExpression, update BinaryExpression for &&, ||, %
  ast-renderer.js    # Add UnaryExpression node type and legend
  reference.js       # Update operators section
tests/
  operators.spec.js  # NEW - 25 tests for logical/modulo/unary operators
```

---

## Deliverables

### Lexer
- [ ] Add `%` to OPERATORS
- [ ] Add `and`, `or`, `not` to KEYWORDS

### Parser
- [ ] Add `makeBinaryExpr()` DRY helper
- [ ] Add parseOr() for `or` (lowest binary precedence)
- [ ] Add parseAnd() for `and`
- [ ] Add parseUnary() for `not` and `-`
- [ ] Update parseFactor() to include `%`
- [ ] Refactor parseEquality, parseComparison, parseTerm to use helper
- [ ] Wire up new precedence chain

### Interpreter
- [ ] Add `validateArrayAccess()` DRY helper
- [ ] Refactor IndexExpression to use helper
- [ ] Refactor IndexAssignStatement to use helper
- [ ] Add UnaryExpression case (`not` and `-`)
- [ ] Add `and` case with short-circuit evaluation
- [ ] Add `or` case with short-circuit evaluation
- [ ] Add `%` case in BinaryExpression

### AST Renderer
- [ ] Add UnaryExpression to getNodeLabel()
- [ ] Add UnaryExpression to getChildren()
- [ ] Add Unary to legend

### Reference Panel
- [ ] Add `and`, `or`, `not` to keywords
- [ ] Update operators to include `%`, `-x`

### Tests
- [ ] Create tests/operators.spec.js with 25 tests
- [ ] All tests passing (229+ total)

---

## Example Program

Add to examples for demonstrating new operators:

```javascript
window.EXAMPLES['operators'] = {
  name: 'Logical Operators',
  description: 'Boolean logic and modulo',
  code: `// Logical AND
let age = 25
let hasLicense = true
if (age >= 16 and hasLicense) {
  print "Can drive"
}

// Logical OR
let isWeekend = false
let isHoliday = true
if (isWeekend or isHoliday) {
  print "Day off!"
}

// Logical NOT
let isRaining = false
if (not isRaining) {
  print "No umbrella needed"
}

// Modulo - check even/odd
let n = 0
while (n < 6) {
  if (n % 2 == 0) {
    print n + " is even"
  } else {
    print n + " is odd"
  }
  n = n + 1
}

// Unary minus
let temp = 10
print "Opposite: " + -temp`
};
```

---

## Notes

**Why these operators matter:**

- **Logical operators** are essential for any real program with complex conditions
- **Modulo** enables algorithms involving cycles, divisibility, wrapping
- **Unary minus** is a basic expectation - confusing to need `0 - x`

**Design decisions:**

- **Keywords over symbols** - `and`/`or`/`not` are more readable for beginners than `&&`/`||`/`!`. Python and Ruby use this approach.
- **Short-circuit evaluation** for `and` and `or` matches Python/JavaScript behavior
- **Unary `-` precedence** is higher than binary operators (standard)
- **`not` returns boolean** (not the operand) - matches Python behavior

**DRY improvements:**

- **makeBinaryExpr()** - Removes 4 repetitions of BinaryExpression creation in parser
- **validateArrayAccess()** - Removes 2 repetitions of array bounds checking in interpreter

**Future enhancements (not this release):**
- Ternary operator (`?:`) or `if`/`else` expression
- Compound assignment (`+=`, `-=`, etc.)
- Increment/decrement (`++`, `--`)

---

## Status

**COMPLETE** - 229 tests passing

### Completed Deliverables

**Lexer:**
- [x] Add `%` to OPERATORS
- [x] Add `and`, `or`, `not` to KEYWORDS

**Parser:**
- [x] Add `makeBinaryExpr()` DRY helper
- [x] Add parseOr() for `or` (lowest binary precedence)
- [x] Add parseAnd() for `and`
- [x] Add parseUnary() for `not` and `-`
- [x] Update parseFactor() to include `%`
- [x] Refactor parseEquality, parseComparison, parseTerm to use helper
- [x] Wire up new precedence chain

**Interpreter:**
- [x] Add `validateArrayAccess()` DRY helper
- [x] Refactor IndexExpression to use helper
- [x] Refactor IndexAssignStatement to use helper
- [x] Add UnaryExpression case (`not` and `-`)
- [x] Add `and` case with short-circuit evaluation
- [x] Add `or` case with short-circuit evaluation
- [x] Add `%` case in BinaryExpression

**AST Renderer:**
- [x] Add UnaryExpression to getNodeLabel()
- [x] Add UnaryExpression to getChildren()
- [x] Add Unary to legend
- [x] Add CSS for .ast-unaryexpression

**Reference Panel:**
- [x] Add `and`, `or`, `not` to keywords
- [x] Update operators to include `%`, `-x`

**Tests:**
- [x] Create tests/operators.spec.js with 25 tests
- [x] All tests passing (229 total, +25 from Release 13)

**Example:**
- [x] Create src/examples/operators.js
- [x] Add to index.html
