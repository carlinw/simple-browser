<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tiny Language Reference</title>
  <link rel="stylesheet" href="styles/language-help.css">
</head>
<body>
  <header>
    <h1>Tiny Language Reference</h1>
    <nav>
      <button id="breakout-btn" onclick="breakOut()">Open in New Tab</button>
      <button id="back-btn" onclick="goBack()">Back to Code</button>
    </nav>
  </header>
  <script>
    function goBack() {
      if (window.parent !== window) {
        // In iframe, tell parent to hide help
        window.parent.postMessage('hideHelp', '*');
      } else {
        // Direct access, go to index
        window.location.href = 'index.html';
      }
    }

    function breakOut() {
      window.open('language-help.html', '_blank');
    }

    // Hide breakout button if already in own tab
    if (window.parent === window) {
      document.getElementById('breakout-btn').style.display = 'none';
    }
  </script>

  <main>
    <aside id="toc">
      <h2>Contents</h2>
      <ul>
        <li><a href="#hello-world">Hello World</a></li>
        <li>
          <a href="#literals">Literals</a>
          <ul class="toc-subsections">
            <li><a href="#numbers">Numbers</a></li>
            <li><a href="#strings">Strings</a></li>
            <li><a href="#booleans">Booleans</a></li>
            <li><a href="#arrays">Arrays</a></li>
          </ul>
        </li>
        <li>
          <a href="#variables">Variables</a>
          <ul class="toc-subsections">
            <li><a href="#naming">Naming</a></li>
            <li><a href="#declaration">Declaration</a></li>
            <li><a href="#assignment">Assignment</a></li>
            <li><a href="#scoping">Scoping</a></li>
            <li><a href="#block-scope">Block Scope</a></li>
          </ul>
        </li>
        <li>
          <a href="#operators">Operators</a>
          <ul class="toc-subsections">
            <li><a href="#arithmetic">Arithmetic</a></li>
            <li><a href="#comparison">Comparison</a></li>
            <li><a href="#logical">Logical</a></li>
            <li><a href="#string-ops">String</a></li>
            <li><a href="#precedence">Precedence</a></li>
          </ul>
        </li>
        <li>
          <a href="#control-flow">Control Flow</a>
          <ul class="toc-subsections">
            <li><a href="#if-statements">If</a></li>
            <li><a href="#loops">Loops</a></li>
            <li><a href="#stop">Stop</a></li>
          </ul>
        </li>
        <li>
          <a href="#functions">Functions</a>
          <ul class="toc-subsections">
            <li><a href="#builtins">Built-in</a></li>
            <li><a href="#speed-control">Speed Control</a></li>
            <li><a href="#keyboard">Keyboard</a></li>
            <li><a href="#graphics">Graphics</a></li>
            <li><a href="#colors">Colors</a></li>
            <li><a href="#user-defined">User-defined</a></li>
          </ul>
        </li>
        <li>
          <a href="#classes">Classes</a>
          <ul class="toc-subsections">
            <li><a href="#class-definition">Definition</a></li>
            <li><a href="#creating-instances">Instances</a></li>
            <li><a href="#methods">Methods</a></li>
          </ul>
        </li>
      </ul>
    </aside>

    <article id="content">
      <!-- Hello World -->
      <section id="hello-world">
        <h2>Hello World</h2>
        <p>The classic first program - print a message to the output:</p>
        <pre class="code-block"><code>print("Hello, World!")</code></pre>
        <p>Click <strong>Run</strong> to see the output. Add <code>pause()</code> to your code to enter debug mode and inspect variables.</p>
      </section>

      <!-- Literals -->
      <section id="literals">
        <h2>Literals</h2>
        <p>Literals are fixed values written directly in your code.</p>
      </section>

      <!-- Numbers (subsection of Literals) -->
      <section id="numbers" class="subsection">
        <h3>Numbers</h3>
        <p>Tiny has a single number type that handles both integers (whole numbers) and floats (decimal numbers). The interpreter displays them differently in the visualization but they work the same way in expressions.</p>
        <pre class="code-block"><code>42        // integer
-5        // negative integer
3.14      // float
0.5       // float
-2.7      // negative float</code></pre>
        <p>Math operations work on any numbers:</p>
        <pre class="code-block"><code>print(5 / 2)      // 2.5 (float result)
print(4 / 2)      // 2 (integer result)
print(3.5 + 1.5)  // 5 (integer result)</code></pre>
      </section>

      <!-- Strings (subsection of Literals) -->
      <section id="strings" class="subsection">
        <h3>Strings</h3>
        <p>Text enclosed in double quotes. Single quotes are not supported.</p>
        <pre class="code-block"><code>"hello"
"Hello, World!"
""        // empty string</code></pre>
        <p>Strings can be indexed like arrays:</p>
        <pre class="code-block"><code>let word = "hello"
print(word[0])  // "h"
print(word[4])  // "o"
print(word.length())  // 5</code></pre>
      </section>

      <!-- Booleans (subsection of Literals) -->
      <section id="booleans" class="subsection">
        <h3>Booleans</h3>
        <p>Logical values for true/false conditions.</p>
        <pre class="code-block"><code>true
false</code></pre>
      </section>

      <!-- Arrays (subsection of Literals) -->
      <section id="arrays" class="subsection">
        <h3>Arrays</h3>
        <p>Ordered collections of values. Can hold mixed types.</p>
        <pre class="code-block"><code>[1, 2, 3, 4, 5]
[1, "hello", true]    // mixed types
[]                    // empty array
[[1, 2], [3, 4]]      // nested arrays</code></pre>

        <h4>Accessing Elements</h4>
        <p>Arrays are zero-indexed. Reading an index that doesn't exist causes an error:</p>
        <pre class="code-block"><code>let arr = [10, 20, 30]
print(arr[0])   // 10 (first element)
print(arr[2])   // 30 (third element)
print(arr.length()) // 3
print(arr[5])   // Error: Index 5 out of bounds</code></pre>

        <h4>Modifying Elements</h4>
        <pre class="code-block"><code>let arr = [1, 2, 3]
arr[1] = 99
print(arr)  // [1, 99, 3]</code></pre>

        <h4>Growing Arrays</h4>
        <p>Arrays can grow by assigning to indices beyond the current length. Gaps are filled with <code>null</code>:</p>
        <pre class="code-block"><code>let arr = []
arr[0] = 10
arr[1] = 20
arr[2] = 30
print(arr.length())  // 3

// Gaps are filled with null
let sparse = []
sparse[2] = 99
print(sparse[0])  // null
print(sparse[1])  // null
print(sparse[2])  // 99</code></pre>

        <h4>Building Arrays in Loops</h4>
        <p>A common pattern is to build an array using a loop:</p>
        <pre class="code-block"><code>let squares = []
let i = 0
while (i < 5) {
  squares[i] = i * i
  i = i + 1
}
print(squares)  // [0, 1, 4, 9, 16]</code></pre>

        <h4>Nested Arrays</h4>
        <pre class="code-block"><code>let matrix = [[1, 2], [3, 4]]
print(matrix[0][1])  // 2</code></pre>
      </section>

      <!-- Variables (main section) -->
      <section id="variables">
        <h2>Variables</h2>
        <p>Variables store values and must be declared before use. Tiny is dynamically typed - variables can hold any type and change types during execution.</p>
      </section>

      <!-- Naming (subsection of Variables) -->
      <section id="naming" class="subsection">
        <h3>Naming</h3>
        <ul>
          <li>Variable names must start with a letter or underscore</li>
          <li>Names can contain letters, numbers, and underscores</li>
          <li>Names are case-sensitive (<code>foo</code> and <code>Foo</code> are different)</li>
          <li>Cannot use reserved keywords or built-in function names</li>
        </ul>

        <h4>Reserved Keywords</h4>
        <p class="keyword-list">
          <code>and</code> <code>class</code> <code>else</code> <code>equals</code> <code>false</code> <code>function</code> <code>if</code> <code>let</code> <code>new</code> <code>not</code> <code>or</code> <code>return</code> <code>stop</code> <code>this</code> <code>true</code> <code>while</code>
        </p>

        <h4>Built-in Functions</h4>
        <p class="keyword-list">
          <code>circle</code> <code>clear</code> <code>color</code> <code>fast</code> <code>fill</code> <code>fullscreen</code> <code>height</code> <code>input</code> <code>key</code> <code>line</code> <code>looplimit</code> <code>num</code> <code>pause</code> <code>pressed</code> <code>print</code> <code>random</code> <code>rect</code> <code>sleep</code> <code>slow</code> <code>slower</code> <code>stroke</code> <code>text</code> <code>triangle</code> <code>width</code>
        </p>

        <h4>Built-in Methods</h4>
        <p class="keyword-list">
          <code>.length()</code>
        </p>
      </section>

      <!-- Declaration (subsection of Variables) -->
      <section id="declaration" class="subsection">
        <h3>Declaration</h3>
        <p>Use <code>let</code> to declare a variable with an initial value:</p>
        <pre class="code-block"><code>let x = 42
let name = "Connor"
let items = [1, 2, 3]</code></pre>
      </section>

      <!-- Assignment (subsection of Variables) -->
      <section id="assignment" class="subsection">
        <h3>Assignment</h3>
        <p>After declaration, you can reassign variables to new values (even different types):</p>
        <pre class="code-block"><code>let x = 10
x = 20          // reassign to new number
x = "hello"     // dynamic typing - can change type</code></pre>
      </section>

      <!-- Scoping (subsection of Variables) -->
      <section id="scoping" class="subsection">
        <h3>Scoping</h3>

        <p>Tiny uses <strong>lexical scoping</strong> with <strong>block-level scope</strong> (like Java). Variables are looked up starting from the innermost scope and moving outward to the global scope. Each block (<code>if</code>, <code>while</code>, function body) creates a new scope.</p>

        <h4>Global Scope</h4>
        <p>Variables declared at the top level are in the global scope and accessible everywhere:</p>
        <pre class="code-block"><code>let globalVar = 100

function foo() {
  print(globalVar)  // can access global
}

foo()  // prints: 100</code></pre>

        <h4>Function Scope</h4>
        <p>Variables declared inside a function are local to that function:</p>
        <pre class="code-block"><code>function foo() {
  let localVar = 42
  print(localVar)  // works
}

foo()
print(localVar)  // ERROR: Undefined variable</code></pre>

        <h4>Block Scope</h4>
        <p>Tiny uses <strong>block-level scoping</strong> (like Java). Variables declared inside <code>if</code> or <code>while</code> blocks are only accessible within that block:</p>
        <pre class="code-block"><code>if (true) {
  let x = 42
  print(x)  // works: 42
}
print(x)  // ERROR: Undefined variable</code></pre>

        <p>The same applies to <code>while</code> loops:</p>
        <pre class="code-block"><code>let i = 0
while (i < 3) {
  let temp = i * 2
  print(temp)
  i = i + 1
}
print(temp)  // ERROR: Undefined variable</code></pre>

        <p>Variables from outer scopes can still be accessed and modified inside blocks:</p>
        <pre class="code-block"><code>let result = 0
if (true) {
  result = 42  // modifies outer variable
}
print(result)  // 42</code></pre>

        <h4>Scope Chain (Multiple Layers)</h4>
        <p>The scope chain goes up <strong>multiple layers</strong>, not just one. Inner functions can access variables from all enclosing scopes:</p>
        <pre class="code-block"><code>let global = 100

function outer() {
  let outerVar = 50

  function inner() {
    let innerVar = 10
    // Can access all three!
    print(innerVar + outerVar + global)
  }

  inner()
}

outer()  // prints: 160</code></pre>

        <div class="info-box">
          <h4>How the Scope Chain Works</h4>
          <p>When <code>inner()</code> runs and needs a variable:</p>
          <ol>
            <li>First checks <strong>inner's scope</strong> → finds <code>innerVar</code></li>
            <li>Checks <strong>outer's scope</strong> (parent) → finds <code>outerVar</code></li>
            <li>Checks <strong>global scope</strong> (grandparent) → finds <code>global</code></li>
          </ol>
          <p>The chain is: <code>inner → outer → global → (not found = error)</code></p>
        </div>

        <h4>Closures</h4>
        <p>Functions capture their surrounding environment when created. This captured environment persists even after the outer function returns:</p>
        <pre class="code-block"><code>function makeCounter() {
  let count = 0

  function increment() {
    count = count + 1
    return count
  }

  return increment
}

let counter = makeCounter()
print(counter())  // 1
print(counter())  // 2
print(counter())  // 3</code></pre>

        <p>Each call to <code>makeCounter()</code> creates a new closure with its own <code>count</code>:</p>
        <pre class="code-block"><code>let counterA = makeCounter()
let counterB = makeCounter()

print(counterA())  // 1
print(counterA())  // 2
print(counterB())  // 1 (independent count)</code></pre>

        <h4>Variable Shadowing</h4>
        <p>A local variable can have the same name as an outer variable, "shadowing" it:</p>
        <pre class="code-block"><code>let x = 10

function foo() {
  let x = 99  // shadows the outer x
  print(x)    // 99
}

foo()
print(x)  // 10 (outer x unchanged)</code></pre>

        <h4>Assignment vs Declaration</h4>
        <p>Using <code>let</code> creates a new variable in the current scope. Assignment without <code>let</code> modifies an existing variable in the scope chain:</p>
        <pre class="code-block"><code>let x = 10

function foo() {
  x = 99  // modifies outer x (no let)
}

foo()
print(x)  // 99</code></pre>
      </section>

      <!-- Operators -->
      <section id="operators">
        <h2>Operators</h2>
        <p>Operators perform computations and comparisons on values.</p>
      </section>

      <!-- Arithmetic (subsection of Operators) -->
      <section id="arithmetic" class="subsection">
        <h3>Arithmetic</h3>
        <table class="ref-table">
          <thead>
            <tr><th>Operator</th><th>Description</th><th>Example</th></tr>
          </thead>
          <tbody>
            <tr><td><code>+</code></td><td>Addition</td><td><code>5 + 3</code> → <code>8</code></td></tr>
            <tr><td><code>-</code></td><td>Subtraction</td><td><code>5 - 3</code> → <code>2</code></td></tr>
            <tr><td><code>*</code></td><td>Multiplication</td><td><code>5 * 3</code> → <code>15</code></td></tr>
            <tr><td><code>/</code></td><td>Division</td><td><code>15 / 3</code> → <code>5</code></td></tr>
            <tr><td><code>%</code></td><td>Modulo (remainder)</td><td><code>7 % 3</code> → <code>1</code></td></tr>
            <tr><td><code>-x</code></td><td>Negation</td><td><code>-5</code></td></tr>
          </tbody>
        </table>
      </section>

      <!-- Comparison (subsection of Operators) -->
      <section id="comparison" class="subsection">
        <h3>Comparison</h3>
        <table class="ref-table">
          <thead>
            <tr><th>Operator</th><th>Description</th><th>Example</th></tr>
          </thead>
          <tbody>
            <tr><td><code>equals</code></td><td>Equal to</td><td><code>5 equals 5</code> → <code>true</code></td></tr>
            <tr><td><code>not equals</code></td><td>Not equal to</td><td><code>5 not equals 3</code> → <code>true</code></td></tr>
            <tr><td><code>&lt;</code></td><td>Less than</td><td><code>3 &lt; 5</code> → <code>true</code></td></tr>
            <tr><td><code>&gt;</code></td><td>Greater than</td><td><code>5 &gt; 3</code> → <code>true</code></td></tr>
            <tr><td><code>&lt;=</code></td><td>Less than or equal</td><td><code>3 &lt;= 3</code> → <code>true</code></td></tr>
            <tr><td><code>&gt;=</code></td><td>Greater than or equal</td><td><code>5 &gt;= 5</code> → <code>true</code></td></tr>
          </tbody>
        </table>
      </section>

      <!-- Logical (subsection of Operators) -->
      <section id="logical" class="subsection">
        <h3>Logical</h3>
        <table class="ref-table">
          <thead>
            <tr><th>Operator</th><th>Description</th><th>Example</th></tr>
          </thead>
          <tbody>
            <tr><td><code>and</code></td><td>Logical AND</td><td><code>true and false</code> → <code>false</code></td></tr>
            <tr><td><code>or</code></td><td>Logical OR</td><td><code>true or false</code> → <code>true</code></td></tr>
            <tr><td><code>not</code></td><td>Logical NOT</td><td><code>not true</code> → <code>false</code></td></tr>
          </tbody>
        </table>
      </section>

      <!-- String (subsection of Operators) -->
      <section id="string-ops" class="subsection">
        <h3>String</h3>
        <p>The <code>+</code> operator concatenates strings:</p>
        <pre class="code-block"><code>let greeting = "Hello, " + "World!"  // "Hello, World!"
let msg = "Age: " + 25               // "Age: 25"</code></pre>
      </section>

      <!-- Precedence (subsection of Operators) -->
      <section id="precedence" class="subsection">
        <h3>Precedence</h3>
        <p>From highest to lowest:</p>
        <ol>
          <li><code>not</code>, <code>-</code> (unary)</li>
          <li><code>*</code>, <code>/</code>, <code>%</code></li>
          <li><code>+</code>, <code>-</code></li>
          <li><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li>
          <li><code>equals</code>, <code>not equals</code></li>
          <li><code>and</code></li>
          <li><code>or</code></li>
        </ol>
        <p>Use parentheses to override: <code>(2 + 3) * 4</code> → <code>20</code></p>
      </section>

      <!-- Control Flow -->
      <section id="control-flow">
        <h2>Control Flow</h2>
        <p>Control flow statements determine which code runs and in what order.</p>
      </section>

      <!-- If Statements (subsection of Control Flow) -->
      <section id="if-statements" class="subsection">
        <h3>If</h3>
        <pre class="code-block"><code>if (condition) {
  // executed if condition is true
}</code></pre>

        <h4>If-Else</h4>
        <pre class="code-block"><code>if (x > 0) {
  print("positive")
} else {
  print("not positive")
}</code></pre>

        <h4>Else If</h4>
        <p>Use <code>else if</code> for multiple conditions:</p>
        <pre class="code-block"><code>if (grade >= 90) {
  print("A")
} else if (grade >= 80) {
  print("B")
} else if (grade >= 70) {
  print("C")
} else {
  print("D or F")
}</code></pre>
        <p>The first matching condition runs, then the rest are skipped.</p>
      </section>

      <!-- Loops (subsection of Control Flow) -->
      <section id="loops" class="subsection">
        <h3>Loops</h3>
        <p>The <code>while</code> loop repeats code as long as a condition is true:</p>
        <pre class="code-block"><code>let i = 0
while (i < 5) {
  print(i)
  i = i + 1
}</code></pre>

        <div class="info-box">
          <h4>Loop Limit</h4>
          <p>To prevent infinite loops from freezing your browser, loops are limited to <strong>10,000 iterations</strong> by default. If exceeded, the program stops with an error. Use <code>looplimit(n)</code> to change the limit.</p>
        </div>
      </section>

      <!-- Stop (subsection of Control Flow) -->
      <section id="stop" class="subsection">
        <h3>Stop</h3>
        <p>The <code>stop</code> keyword immediately terminates program execution:</p>
        <pre class="code-block"><code>while (true) {
  let input = key()
  if (input equals "q") {
    stop  // exit the program
  }
}</code></pre>
      </section>

      <!-- Functions (main section) -->
      <section id="functions">
        <h2>Functions</h2>
        <p>Functions let you organize code into reusable blocks. Tiny has built-in functions and you can define your own.</p>
      </section>

      <!-- Built-in Functions (subsection of Functions) -->
      <section id="builtins" class="subsection">
        <h3>Built-in</h3>

        <table class="ref-table">
          <thead>
            <tr><th>Function</th><th>Description</th><th>Example</th></tr>
          </thead>
          <tbody>
            <tr>
              <td><code>print(x)</code></td>
              <td>Output a value to the console</td>
              <td><code>print("Hello")</code></td>
            </tr>
            <tr>
              <td><code>x.length()</code></td>
              <td>Length of array or string</td>
              <td><code>[1,2,3].length()</code> → <code>3</code></td>
            </tr>
            <tr>
              <td><code>num(x)</code></td>
              <td>Convert string to number</td>
              <td><code>num("42")</code> → <code>42</code></td>
            </tr>
            <tr>
              <td><code>random(min, max)</code></td>
              <td>Random integer in range [min, max]</td>
              <td><code>random(1, 6)</code></td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- Speed Control (subsection of Functions) -->
      <section id="speed-control" class="subsection">
        <h3>Speed Control</h3>
        <p>These functions control execution and enable debugging. Use <code>pause()</code> to enter debug mode where you can inspect variables and step through code.</p>

        <table class="ref-table">
          <thead>
            <tr><th>Function</th><th>Description</th></tr>
          </thead>
          <tbody>
            <tr>
              <td><code>pause()</code></td>
              <td>Enter debug mode - shows variables and step buttons</td>
            </tr>
            <tr>
              <td><code>sleep(ms)</code></td>
              <td>Pause execution for specified milliseconds</td>
            </tr>
            <tr>
              <td><code>looplimit(n)</code></td>
              <td>Set max loop iterations (default: 10000)</td>
            </tr>
            <tr>
              <td><code>slow()</code></td>
              <td>Set step delay to 1 second (for animation)</td>
            </tr>
            <tr>
              <td><code>slower()</code></td>
              <td>Set step delay to 2 seconds (for animation)</td>
            </tr>
            <tr>
              <td><code>fast()</code></td>
              <td>Remove step delay (instant execution)</td>
            </tr>
          </tbody>
        </table>

        <h4>Debug Mode</h4>
        <p>When <code>pause()</code> is called, the code pane splits to show the call stack with all variables. Three buttons appear:</p>
        <ul>
          <li><strong>Step Into</strong> - Execute ONE statement, entering function calls to step through them line by line</li>
          <li><strong>Step Over</strong> - Execute ONE statement, running entire functions without stopping inside them</li>
          <li><strong>Resume</strong> - Continue running until the next <code>pause()</code> or end of program</li>
        </ul>
        <p>Stack frames show the function name, parameters, local variables, and which line called the function.</p>

        <h4>Example: Debugging a Loop</h4>
        <pre class="code-block"><code>let total = 0
let i = 0
while (i < 5) {
  total = total + i
  i = i + 1
  pause()  // inspect variables each iteration
}
print(total)</code></pre>

        <h4>Example: Debugging a Function</h4>
        <pre class="code-block"><code>function add(a, b) {
  let sum = a + b
  pause()  // see function's local variables
  return sum
}

let result = add(3, 4)
print(result)</code></pre>
      </section>

      <!-- Keyboard (subsection of Functions) -->
      <section id="keyboard" class="subsection">
        <h3>Keyboard</h3>

        <table class="ref-table">
          <thead>
            <tr><th>Function</th><th>Description</th><th>Example</th></tr>
          </thead>
          <tbody>
            <tr>
              <td><code>input()</code></td>
              <td>Read a line of text input</td>
              <td><code>let name = input()</code></td>
            </tr>
            <tr>
              <td><code>key()</code></td>
              <td>Wait for and return single keypress</td>
              <td><code>let k = key()</code></td>
            </tr>
            <tr>
              <td><code>pressed(key)</code></td>
              <td>Check if key is currently held down</td>
              <td><code>pressed("ArrowUp")</code></td>
            </tr>
          </tbody>
        </table>

        <h4>Common Key Names</h4>
        <p>For <code>key()</code> and <code>pressed()</code>:</p>
        <ul class="key-list">
          <li><code>"ArrowUp"</code>, <code>"ArrowDown"</code>, <code>"ArrowLeft"</code>, <code>"ArrowRight"</code></li>
          <li><code>"Enter"</code>, <code>"Space"</code>, <code>"Escape"</code></li>
          <li><code>"a"</code> - <code>"z"</code> (lowercase letters)</li>
          <li><code>"0"</code> - <code>"9"</code> (digits)</li>
        </ul>

        <h4>Example: Arrow Key Movement</h4>
        <pre class="code-block"><code>let x = 100
let y = 100

while (true) {
  if (pressed("ArrowUp")) { y = y - 5 }
  if (pressed("ArrowDown")) { y = y + 5 }
  if (pressed("ArrowLeft")) { x = x - 5 }
  if (pressed("ArrowRight")) { x = x + 5 }

  clear()
  color("white")
  circle(x, y, 10)
  sleep(16)
}</code></pre>
      </section>

      <!-- Graphics (subsection of Functions) -->
      <section id="graphics" class="subsection">
        <h3>Graphics</h3>
        <p>Graphics functions draw to a canvas. The canvas appears automatically when any graphics function is called.</p>

        <h4>Output Modes</h4>
        <p>Tiny has two output modes:</p>
        <ul>
          <li><strong>Text Mode:</strong> When you only use <code>print()</code>, output appears as scrollable text.</li>
          <li><strong>Mixed Mode:</strong> When you use graphics functions like <code>clear()</code>, a canvas appears. Any <code>print()</code> statements will appear in a text area below the canvas, similar to the Apple II's split-screen mode.</li>
        </ul>
        <pre class="code-block"><code>// Mixed mode example
clear()
color("red")
circle(100, 100, 50)
print("Score: 100")  // appears below canvas</code></pre>

        <h4>Canvas Setup</h4>
        <table class="ref-table">
          <thead>
            <tr><th>Function</th><th>Description</th></tr>
          </thead>
          <tbody>
            <tr><td><code>clear()</code></td><td>Clear canvas to black</td></tr>
            <tr><td><code>fullscreen()</code></td><td>Enter fullscreen mode (ESC to exit)</td></tr>
            <tr><td><code>width()</code></td><td>Get current canvas width</td></tr>
            <tr><td><code>height()</code></td><td>Get current canvas height</td></tr>
          </tbody>
        </table>

        <h4>Drawing</h4>
        <table class="ref-table">
          <thead>
            <tr><th>Function</th><th>Description</th></tr>
          </thead>
          <tbody>
            <tr><td><code>color(name)</code></td><td>Set drawing color (see Colors below)</td></tr>
            <tr><td><code>rect(x, y, w, h)</code></td><td>Draw rectangle at (x,y) with width w, height h</td></tr>
            <tr><td><code>circle(x, y, r)</code></td><td>Draw circle at (x,y) with radius r</td></tr>
            <tr><td><code>line(x1, y1, x2, y2)</code></td><td>Draw line from (x1,y1) to (x2,y2)</td></tr>
            <tr><td><code>triangle(x1,y1,x2,y2,x3,y3)</code></td><td>Draw triangle with three vertices</td></tr>
            <tr><td><code>text(x, y, str)</code></td><td>Draw text at position (x,y)</td></tr>
          </tbody>
        </table>

        <h4>Drawing Modes</h4>
        <table class="ref-table">
          <thead>
            <tr><th>Function</th><th>Description</th></tr>
          </thead>
          <tbody>
            <tr><td><code>fill()</code></td><td>Shapes are filled solid (default)</td></tr>
            <tr><td><code>stroke()</code></td><td>Shapes are outlined only</td></tr>
          </tbody>
        </table>

        <h4>Example: Bouncing Ball</h4>
        <pre class="code-block"><code>let x = 100
let y = 100
let dx = 3
let dy = 2

while (true) {
  // Move
  x = x + dx
  y = y + dy

  // Bounce off walls
  if (x < 10 or x > width() - 10) { dx = -dx }
  if (y < 10 or y > height() - 10) { dy = -dy }

  // Draw
  clear()
  color("red")
  circle(x, y, 10)

  sleep(16)
}</code></pre>
      </section>

      <!-- Colors (subsection of Functions) -->
      <section id="colors" class="subsection">
        <h3>Colors</h3>
        <p>Available color names for the <code>color()</code> function:</p>

        <div class="color-grid" id="color-grid">
          <!-- Colors will be populated by JavaScript -->
        </div>
      </section>

      <!-- User-defined Functions (subsection of Functions) -->
      <section id="user-defined" class="subsection">
        <h3>User-defined</h3>

        <h4>Declaration</h4>
        <pre class="code-block"><code>function greet(name) {
  print("Hello, " + name)
}

greet("Connor")  // prints: Hello, Connor</code></pre>

        <h4>Return Values</h4>
        <pre class="code-block"><code>function add(a, b) {
  return a + b
}

let sum = add(3, 4)  // sum = 7</code></pre>

        <h4>Multiple Parameters</h4>
        <pre class="code-block"><code>function volume(width, height, depth) {
  return width * height * depth
}

print(volume(2, 3, 4))  // prints: 24</code></pre>

        <h4>Recursion</h4>
        <p>Functions can call themselves:</p>
        <pre class="code-block"><code>function factorial(n) {
  if (n <= 1) {
    return 1
  }
  return n * factorial(n - 1)
}

print(factorial(5))  // prints: 120</code></pre>
      </section>

      <!-- Classes (main section) -->
      <section id="classes">
        <h2>Classes</h2>
        <p>Objects let you work with complex things by building them from simpler things, and those from even simpler things—all the way down to primitives.</p>

        <ul>
          <li><strong>Compose:</strong> Bundle variables into concepts (Player = name + x + y + health)</li>
          <li><strong>Nest:</strong> Build bigger concepts from smaller ones (Team has Players, Game has Teams)</li>
          <li><strong>Pass around:</strong> One reference handles the whole bundle</li>
          <li><strong>Organize:</strong> Code lives with the data it operates on</li>
        </ul>

        <h4>Without Classes vs With Classes</h4>
        <p>Without classes, you might track a player like this:</p>
        <pre class="code-block"><code>// Without classes - messy!
let player1X = 100
let player1Y = 200
let player1Health = 10
let player1Name = "Connor"

let player2X = 300
let player2Y = 200
let player2Health = 10
let player2Name = "Alex"

// Functions need lots of parameters
function movePlayer(x, y, dx, dy) { ... }</code></pre>

        <p>With classes, each player is a self-contained object:</p>
        <pre class="code-block"><code>// With classes - clean!
class Player {
  name, x, y, health,

  move(dx, dy) {
    this.x = this.x + dx
    this.y = this.y + dy
  }
}

let player1 = new Player("Connor", 100, 200, 10)
let player2 = new Player("Alex", 300, 200, 10)

player1.move(5, 0)  // player1 moves itself</code></pre>
      </section>

      <!-- Class Definition (subsection of Classes) -->
      <section id="class-definition" class="subsection">
        <h3>Definition</h3>
        <p>Define a class with fields (data) and methods (behavior):</p>
        <pre class="code-block"><code>class Player {
  name,
  x,
  y,
  health,

  takeDamage(amount) {
    this.health = this.health - amount
  }
}</code></pre>
        <p>Fields are listed first (separated by commas), followed by methods.</p>
      </section>

      <!-- Creating Instances (subsection of Classes) -->
      <section id="creating-instances" class="subsection">
        <h3>Instances</h3>
        <p>Create an instance with <code>new</code>, passing values for each field in order:</p>
        <pre class="code-block"><code>let p = new Player("Connor", 100, 200, 10)
print(p.name)    // "Connor"
print(p.x)       // 100
print(p.health)  // 10</code></pre>

        <h4>Modifying Fields</h4>
        <p>Access and modify fields with dot notation:</p>
        <pre class="code-block"><code>p.x = 150
p.health = p.health - 1
print(p.x)       // 150
print(p.health)  // 9</code></pre>
      </section>

      <!-- Methods (subsection of Classes) -->
      <section id="methods" class="subsection">
        <h3>Methods</h3>
        <p>Methods are functions that operate on instance data. Use <code>this</code> to access fields:</p>
        <pre class="code-block"><code>class Point {
  x,
  y,

  move(dx, dy) {
    this.x = this.x + dx
    this.y = this.y + dy
  }

  distanceFromOrigin() {
    return this.x + this.y
  }
}

let pt = new Point(10, 20)
pt.move(5, -3)
print(pt.x)  // 15
print(pt.y)  // 17
print(pt.distanceFromOrigin())  // 32</code></pre>

        <h4>Methods with Return Values</h4>
        <pre class="code-block"><code>class Rectangle {
  width,
  height,

  area() {
    return this.width * this.height
  }
}

let r = new Rectangle(10, 5)
print(r.area())  // 50</code></pre>
      </section>
    </article>
  </main>

  <footer>
    <p>Tiny Language Reference</p>
  </footer>

  <script>
    // Color definitions (duplicated from src/constants.js for standalone use)
    // Organized by hue for easy browsing
    const COLORS = {
      // Neutrals
      white: '#ffffff',
      lightgray: '#d3d3d3',
      gray: '#888888',
      darkgray: '#444444',
      black: '#000000',

      // Reds
      red: '#ff0000',
      crimson: '#dc143c',
      salmon: '#fa8072',
      coral: '#ff7f50',

      // Oranges/Browns
      orange: '#ff8800',
      brown: '#8b4513',

      // Yellows
      yellow: '#ffff00',
      beige: '#f5f5dc',
      ivory: '#fffff0',

      // Greens
      lime: '#00ff00',
      green: '#228b22',
      forestgreen: '#228b22',
      seagreen: '#2e8b57',

      // Cyans
      cyan: '#00ffff',
      turquoise: '#40e0d0',
      skyblue: '#87ceeb',

      // Blues
      blue: '#0000ff',
      steelblue: '#4682b4',
      navy: '#000080',
      indigo: '#4b0082',

      // Purples/Pinks
      purple: '#8800ff',
      violet: '#ee82ee',
      magenta: '#ff00ff',
      pink: '#ff88ff',
      hotpink: '#ff69b4',
      lavender: '#e6e6fa',
      plum: '#dda0dd',
      orchid: '#da70d6'
    };

    // Populate color grid
    const colorGrid = document.getElementById('color-grid');
    Object.entries(COLORS).forEach(([name, hex]) => {
      const swatch = document.createElement('div');
      swatch.className = 'color-swatch';
      swatch.innerHTML = `
        <div class="swatch-preview" style="background-color: ${hex}"></div>
        <div class="swatch-info">
          <code>${name}</code>
          <span class="hex">${hex}</span>
        </div>
      `;
      colorGrid.appendChild(swatch);
    });
  </script>
</body>
</html>
